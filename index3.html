<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Web BLE LIVE parser (updated offsets)</title>
  <style>
    body { font-family: Arial, sans-serif; margin:16px; }
    .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    label { font-size:0.9rem; }
    input[type="text"], input[type="number"] { padding:6px; font-family:monospace; }
    input.small { width:120px; }
    .box { border:1px solid #ddd; padding:8px; background:#fafafa; min-width:280px; }
    #recvRaw { height:160px; overflow:auto; border:1px solid #ccc; padding:8px; background:#111; color:#0f0; font-family:monospace; }
    #parsed { display:grid; grid-template-columns:repeat(auto-fit,minmax(160px,1fr)); gap:8px; margin-top:8px; }
    button { padding:6px 10px; }
  </style>
</head>
<body>
  <h3>Compact LIVE Data UI — updated offsets</h3>

  <div class="row">
    <button id="connectButton">Connect</button>
    <button id="disconnectButton" disabled>Disconnect</button>
    <button id="sendLiveBtn" disabled>SEND LIVE CMD</button>
  </div>

  <hr />

  <div style="display:flex;gap:12px;align-items:flex-start;">
    <div style="flex:1">
      <div class="box">
        <strong>Raw Receive (Docklight hex)</strong>
        <div id="recvRaw"></div>
        <div style="margin-top:8px;">
          <button id="clearRaw">Clear Raw</button>
          <button id="forceParse">Parse latest (force)</button>
        </div>
      </div>
    </div>

    <div style="width:420px">
      <div class="box">
        <strong>LIVE Data (parsed)</strong>
        <div id="parsed">
          <div><label>Battery (mV)</label><br><input id="battery_mV" class="small" type="number" readonly /></div>
          <div><label>Current (mA)</label><br><input id="current_mA" class="small" type="number" readonly /></div>
          <div><label>Temp</label><br><input id="tempC" class="small" type="number" readonly /></div>
          <div><label>Min Freq (Hz)</label><br><input id="minHz" class="small" type="number" readonly /></div>
          <div><label>Max Freq (Hz)</label><br><input id="maxHz" class="small" type="number" readonly /></div>
          <div><label>Wave vel</label><br><input id="waveVel" class="small" type="number" readonly /></div>
          <div><label>Pattern</label><br><input id="pattern" class="small" type="number" readonly /></div>
          <div><label>Uptime Days</label><br><input id="days" class="small" type="number" readonly /></div>
          <div><label>HH:MM:SS</label><br><input id="hhmmss" class="small" type="text" readonly /></div>
        </div>
        <div style="margin-top:8px;">
          <button id="copyParsed">Copy parsed</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    // UUIDs and LIVE command (unchanged)
    const serviceUuid = "0000fff0-0000-1000-8000-00805f9b34fb";
    const notifyCharUuid = "0000fff1-0000-1000-8000-00805f9b34fb";
    const writeCharUuid = "0000fff2-0000-1000-8000-00805f9b34fb";
    const LIVE_CMD_HEX = "FD FC FB FA 04 00 4C 49 56 45 04 03 02 01";

    // DOM
    const connectButton = document.getElementById("connectButton");
    const disconnectButton = document.getElementById("disconnectButton");
    const sendLiveBtn = document.getElementById("sendLiveBtn");
    const recvRaw = document.getElementById("recvRaw");
    const clearRaw = document.getElementById("clearRaw");
    const forceParse = document.getElementById("forceParse");

    const battery_mV = document.getElementById("battery_mV");
    const current_mA = document.getElementById("current_mA");
    const tempC = document.getElementById("tempC");
    const minHz = document.getElementById("minHz");
    const maxHz = document.getElementById("maxHz");
    const waveVel = document.getElementById("waveVel");
    const pattern = document.getElementById("pattern");
    const days = document.getElementById("days");
    const hhmmss = document.getElementById("hhmmss");
    const copyParsed = document.getElementById("copyParsed");

    // BLE vars
    let device, server, notifyChar, writeChar;
    let lastPacket = null;

    function bytesToHexUpper(bytes) {
      return Array.from(bytes).map(b => b.toString(16).padStart(2,"0").toUpperCase()).join(" ");
    }

    function appendRaw(bytes) {
      const t = new Date().toLocaleTimeString();
      lastPacket = bytes;
      recvRaw.innerHTML += `[${t}] ${bytesToHexUpper(bytes)}<br>`;
      recvRaw.scrollTop = recvRaw.scrollHeight;
    }

    // safe readers
    function readU8(buf, idx) { return (idx < buf.length) ? buf[idx] : null; }
    function readU16le(buf, lowIdx, highIdx) {
      const l = readU8(buf, lowIdx), h = readU8(buf, highIdx);
      if (l === null || h === null) return null;
      return (h << 8) | l;
    }

    // Updated parser using absolute indices (zero-indexed). If buffer shorter than needed,
    // fallback to searching for "LIVE" tag and relative offsets (previous heuristic).
    function parseLivePacket(bytes) {
      const buf = Uint8Array.from(bytes);
      // required highest index = 27
      const ABS_NEEDED = 28;
      let useAbsolute = (buf.length >= ABS_NEEDED);

      let parsed = {};
      if (useAbsolute) {
        // Absolute indexes as provided by you:
        // Battery: 10,11 ; Current:12,13 ; Temp:14,15 ; Min:16,17 ; Max:18,19 ;
        // Wave:20,21 ; Pattern:22 ; Days:23,24 ; HH:25 ; MM:26 ; SS:27
        parsed.battery_mV = readU16le(buf, 10, 11);
        parsed.current_mA = readU16le(buf, 12, 13); // treated as mA per your note
        parsed.temp = readU16le(buf, 14, 15); // if temp is 8-bit in firmware, hi byte may be 0
        parsed.min_Hz = readU16le(buf, 16, 17);
        parsed.max_Hz = readU16le(buf, 18, 19);
        parsed.waveVal = readU16le(buf, 20, 21);
        parsed.pattern = readU8(buf, 22);
        parsed.days = readU16le(buf, 23, 24);
        parsed.hh = readU8(buf, 25);
        parsed.mm = readU8(buf, 26);
        parsed.ss = readU8(buf, 27);

        parsed.mode = "absolute";
        parsed.rawHex = bytesToHexUpper(buf);
        return parsed;
      }

      // Fallback heuristic: search for ASCII "LIVE" and use previous relative offsets.
      let idx = -1;
      for (let i=0; i <= buf.length - 4; ++i) {
        if (buf[i] === 0x4C && buf[i+1] === 0x49 && buf[i+2] === 0x56 && buf[i+3] === 0x45) { idx = i; break; }
      }
      if (idx < 0) return { error: "LIVE tag not found and packet too short for absolute offsets." };

      // relative offsets (as earlier heuristic) — adjust if needed later
      parsed.battery_mV = readU16le(buf, idx + 4, idx + 5);
      parsed.min_Hz = readU16le(buf, idx + 8, idx + 9);
      parsed.max_Hz = readU16le(buf, idx + 10, idx + 11);
      parsed.waveVal = readU16le(buf, idx + 12, idx + 13);
      parsed.pattern = readU8(buf, idx + 14);
      parsed.current_mA = (readU16le(buf, idx + 15, idx + 16) !== null) ? readU16le(buf, idx + 15, idx + 16) : null;
      parsed.temp = readU8(buf, idx + 17);
      parsed.days = readU16le(buf, idx + 18, idx + 19);
      parsed.hh = readU8(buf, idx + 20);
      parsed.mm = readU8(buf, idx + 21);
      parsed.ss = readU8(buf, idx + 22);

      parsed.mode = "relative";
      parsed.rawHex = bytesToHexUpper(buf);
      return parsed;
    }

    function showParsed(obj) {
      if (!obj || obj.error) {
        battery_mV.value = ""; current_mA.value = ""; tempC.value = ""; minHz.value = "";
        maxHz.value = ""; waveVel.value = ""; pattern.value = ""; days.value = ""; hhmmss.value = "";
        return;
      }
      battery_mV.value = (obj.battery_mV !== null && obj.battery_mV !== undefined) ? obj.battery_mV : "";
      current_mA.value = (obj.current_mA !== null && obj.current_mA !== undefined) ? obj.current_mA : "";
      tempC.value = (obj.temp !== null && obj.temp !== undefined) ? obj.temp : "";
      minHz.value = (obj.min_Hz !== null && obj.min_Hz !== undefined) ? obj.min_Hz : "";
      maxHz.value = (obj.max_Hz !== null && obj.max_Hz !== undefined) ? obj.max_Hz : "";
      waveVel.value = (obj.waveVal !== null && obj.waveVal !== undefined) ? obj.waveVal : "";
      pattern.value = (obj.pattern !== null && obj.pattern !== undefined) ? obj.pattern : "";
      days.value = (obj.days !== null && obj.days !== undefined) ? obj.days : "";
      hhmmss.value = (obj.hh !== undefined) ? `${String(obj.hh).padStart(2,"0")}:${String(obj.mm||0).padStart(2,"0")}:${String(obj.ss||0).padStart(2,"0")}` : "";
    }

    // BLE connection and handlers
    async function connect() {
      try {
        device = await navigator.bluetooth.requestDevice({
          filters: [{ namePrefix: "CARCAT" }, { name: "CARCAT_5G" }],
          optionalServices: [serviceUuid],
        });
        server = await device.gatt.connect();
        const svc = await server.getPrimaryService(serviceUuid);
        notifyChar = await svc.getCharacteristic(notifyCharUuid);
        writeChar = await svc.getCharacteristic(writeCharUuid);

        await notifyChar.startNotifications();
        notifyChar.addEventListener("characteristicvaluechanged", onNotify);

        connectButton.disabled = true;
        disconnectButton.disabled = false;
        sendLiveBtn.disabled = false;
      } catch (e) {
        alert("Connect failed: " + e);
      }
    }

    async function disconnect() {
      try { if (device && device.gatt.connected) device.gatt.disconnect(); }
      finally { connectButton.disabled = false; disconnectButton.disabled = true; sendLiveBtn.disabled = true; }
    }

    function onNotify(ev) {
      const arr = new Uint8Array(ev.target.value.buffer);
      appendRaw(arr);
      // auto-parse
      const parsed = parseLivePacket(arr);
      if (!parsed.error) showParsed(parsed);
    }

    async function sendLiveCmd() {
      if (!writeChar) { alert("Not connected"); return; }
      const cleaned = LIVE_CMD_HEX.replace(/0x/g, "").replace(/[^A-Fa-f0-9]/g,"");
      const b = new Uint8Array(cleaned.length/2);
      for (let i=0;i<cleaned.length;i+=2) b[i/2] = parseInt(cleaned.substr(i,2),16);
      try { await writeChar.writeValue(b); }
      catch (e) { alert("Write error: " + e); }
    }

    // UI handlers
    connectButton.addEventListener("click", connect);
    disconnectButton.addEventListener("click", disconnect);
    sendLiveBtn.addEventListener("click", sendLiveCmd);
    clearRaw.addEventListener("click", () => recvRaw.innerHTML = "");
    forceParse.addEventListener("click", () => {
      if (!lastPacket) return alert("No packet available");
      const parsed = parseLivePacket(lastPacket);
      if (parsed.error) alert(parsed.error); else showParsed(parsed);
    });

    copyParsed.addEventListener("click", async () => {
      const lines = [
        `Battery mV: ${battery_mV.value}`,
        `Current mA: ${current_mA.value}`,
        `Temp: ${tempC.value}`,
        `Min Hz: ${minHz.value}`,
        `Max Hz: ${maxHz.value}`,
        `Wave: ${waveVel.value}`,
        `Pattern: ${pattern.value}`,
        `Days: ${days.value}`,
        `HH:MM:SS: ${hhmmss.value}`
      ].join("\n");
      await navigator.clipboard.writeText(lines);
      alert("Parsed copied to clipboard");
    });

    if (!navigator.bluetooth) {
      alert("Web Bluetooth not available in this browser.");
      connectButton.disabled = true;
    }
  </script>
</body>
</html>
