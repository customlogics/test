<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>CARCAT 5G — Dashboard (BLE)</title>
<style>
  :root{
    --bg: #0f1114;
    --card: #14202a;
    --text: #ffffff;
    --muted: #9fb0c0;
    --accent-1: #27b56b;
    --accent-2: #3b82f6;
    --accent-3: #ff9f6b;
    --accent-4: #9b62ff;
    --icon-yellow: #FFD54A;    /* only icons + top title use this */
    --glass: rgba(255,255,255,0.03);
    --card-radius: 14px;
  }

  html,body{height:100%;margin:0;font-family:Inter, "Segoe UI", Roboto, Arial; background:linear-gradient(180deg,#0b0c0e 0%, #0f1114 100%); color:var(--text);}
  .wrap{max-width:1120px;margin:18px auto;padding:18px;display:grid;grid-template-columns:360px 1fr;gap:18px;}
  .left{display:flex;flex-direction:column;gap:18px;}
  .hero{background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:var(--card-radius);padding:18px;border-left:6px solid var(--accent-1);}
  .hero h1{margin:0;font-size:20px;color:var(--icon-yellow)} /* only the top title is yellow */
  .hero p{margin:8px 0 0 0;color:var(--muted);font-size:13px;}
  .small-card{background:var(--card); padding:12px; border-radius:12px; border-left:6px solid var(--accent-2); color:inherit}

  .grid{display:grid;grid-template-columns:repeat(2,1fr);gap:14px;}
  .tile{background:var(--card); border-radius:var(--card-radius); padding:18px; position:relative; overflow:hidden; box-shadow:0 6px 20px rgba(3,6,9,0.6);}
  .tile .heading{font-size:16px;font-weight:800;margin-bottom:8px;color:var(--text);display:flex;align-items:center;gap:10px}
  .tile .sub{color:var(--muted);font-size:13px;margin-top:8px}
  .metric{display:flex;align-items:center;gap:12px}
  .metric .value{font-size:26px;font-weight:800;color:var(--text)}
  .metric .unit{color:var(--muted);font-size:12px}
  .feature-card { display:flex; align-items:center; justify-content:space-between; gap:12px; }
  .feature-left {flex:1}
  .feature-title { font-weight:800; color:var(--text) }
  .feature-sub { color:var(--muted); font-size:12px; margin-top:6px }
  .feature-value { font-size:20px; font-weight:800; margin-top:6px; color:var(--text) }
  .gear { border-radius:10px; background:rgba(255,255,255,0.02); border:1px solid rgba(255,255,255,0.03); padding:8px; cursor:pointer; color:var(--muted); font-weight:700 }
  .small-muted { color:var(--muted); font-size:12px }
  .raw { background:var(--glass); padding:10px; border-radius:10px; font-family:monospace; color:var(--accent-1); font-size:13px; height:120px; overflow:auto; border:1px solid rgba(255,255,255,0.03) }
  .footer{grid-column:1/-1;display:flex;justify-content:space-between;align-items:center;margin-top:6px;padding:12px 18px;background:transparent}
  .connectBtn{padding:8px 14px;border-radius:10px;background:linear-gradient(90deg,var(--accent-2),#9be7ff);color:#072031;border:none;cursor:pointer;font-weight:700}
  .btn-ghost{background:transparent;border:1px solid rgba(255,255,255,0.05);color:var(--muted);padding:8px 12px;border-radius:10px;cursor:pointer}
  .badge { display:inline-block;padding:6px 10px;border-radius:999px;background:rgba(255,255,255,0.02); font-weight:700; color:var(--muted); font-size:13px }

  /* ICONS: doubled to 32px (was 16px), stroke slightly increased */
  .icon { width:32px; height:32px; display:inline-block; vertical-align:middle; }
  svg.icon path, svg.icon rect, svg.icon circle { stroke: var(--icon-yellow); stroke-width:1.6; fill: none; }
  svg.icon rect.filled { fill: var(--icon-yellow); stroke: none; }

  .modal-backdrop{position:fixed;inset:0;background:rgba(0,0,0,0.55);display:none;align-items:center;justify-content:center;z-index:2000}
  .modal{width:420px;background:#f2f8ff;color:#0b1220;border-radius:12px;padding:18px;box-shadow:0 6px 30px rgba(0,0,0,0.25);position:relative}
  .modal h2{margin:0 0 8px 0;text-align:center}
  .toggle{display:flex;justify-content:center;align-items:center;gap:12px;margin:8px 0 14px 0}
  .switch{width:54px;height:30px;background:#ddd;border-radius:18px;position:relative}
  .switch.on{background:#111}
  .knob{width:24px;height:24px;background:#fff;border-radius:50%;position:absolute;top:3px;left:3px;transition:left .12s;box-shadow:0 2px 4px rgba(0,0,0,0.2)}
  .switch.on .knob{left:27px}
  .modal input[type="range"]{width:100%}
  .muted{color:var(--muted)}
  @media (max-width:980px){.wrap{grid-template-columns:1fr;padding:12px}.grid{grid-template-columns:1fr}}

  .radio-group { display: flex; gap: 8px; margin-bottom: 8px; }
  .radio-group input[type="radio"] { accent-color: var(--accent-2); }
  .radio-group label { color: var(--muted); font-size: 12px; cursor: pointer; user-select: none; }
</style>
</head>
<body>
  <div class="wrap">
    <!-- LEFT -->
    <div class="left">
      <div class="hero">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div>
            <h1>CARCAT 5G - Wave</h1>
            <p>Car Battery Monitor & Config — BLE control & live telemetry</p>
          </div>
          <div style="text-align:right">
            <div class="muted">Connected to:</div>
            <div id="deviceName" class="badge">Not connected</div>
          </div>
        </div>

        <div style="margin-top:12px;display:flex;gap:8px;align-items:center">
          <button id="connectButton" type="button" class="connectBtn">Connect</button>
          <button id="disconnectButton" class="btn-ghost" disabled>Disconnect</button>
          <button id="sendLiveBtn" class="btn-ghost" disabled>SEND LIVE</button>
        </div>

        <div style="margin-top:12px;display:flex;gap:8px">
          <button id="sendInitBtn" class="btn-ghost" disabled>SEND INIT</button>
          <button id="startAutoBtn" class="btn-ghost" disabled>Start Auto (500ms)</button>
          <button id="stopAutoBtn" class="btn-ghost" disabled>Stop Auto</button>
        </div>

        <div style="margin-top:12px" class="muted">Raw receive (Docklight hex)</div>
        <div id="recvRaw" class="raw"></div>
        <div style="margin-top:8px;display:flex;gap:8px">
          <button id="clearRaw" class="btn-ghost">Clear</button>
          <button id="forceParse" class="btn-ghost">Force LIVE Parse</button>
        </div>
      </div>

      <div class="small-card">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div>
            <div style="font-weight:700; color:var(--text)">Quick</div>
            <div class="muted" style="margin-top:6px">Console logs for TX/RX are in browser console</div>
          </div>
          <div>
            <button id="openSetup" class="btn-ghost">Setup</button>
          </div>
        </div>
      </div>
    </div>

    <!-- RIGHT -->
    <div>
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
        <div style="font-size:18px;font-weight:800; color:var(--text)">Dashboard</div>
        <div class="muted">Auto: <span id="autoStatus">Idle</span></div>
      </div>

      <div class="grid">
        <!-- NEW DEVICE STATUS CARD -->
        <div class="tile" id="card_device_status" style="border-left:6px solid var(--accent-2)">
          <div class="heading">
            <!-- power/mode icon -->
            <svg class="icon" viewBox="0 0 24 24" aria-hidden>
              <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"></path>
            </svg>
            Device Status
          </div>
          <div class="feature-value" id="card_device_status_val">--</div>
          <div class="sub">From LIVE packet (byte 23)</div>
        </div>

        <div class="tile" id="card_voltage" style="border-left:6px solid var(--accent-1)">
          <div class="heading">
            <!-- battery icon -->
            <svg class="icon" viewBox="0 0 24 24" aria-hidden>
              <rect x="2" y="6" width="16" height="12" rx="2"></rect>
              <rect class="filled" x="19" y="9" width="2" height="6" rx="0.5"></rect>
            </svg>
            Car Battery Voltage
          </div>
          <div class="metric">
            <div class="value" id="card_battery">-- V</div>
            <div class="unit muted" id="liveExtra">instant</div>
          </div>
          <div class="sub" id="card_battery_sub">From LIVE packet</div>
        </div>

        <!-- CURRENT card -->
        <div class="tile" id="card_current" style="border-left:6px solid #ffcc00">
          <div class="heading">
            <!-- current icon -->
            <svg class="icon" viewBox="0 0 24 24" aria-hidden>
              <path d="M3 12h7l2 6 2-12 2 6h4"></path>
            </svg>
            Device Current
          </div>
          <div class="metric">
            <div class="value" id="card_current_val">-- mA</div>
            <div class="unit muted">instant</div>
          </div>
          <div class="sub">From LIVE packet (bytes 12-13)</div>
        </div>

        <div class="tile" id="card_temp" style="border-left:6px solid #d6a93e">
          <div class="heading">
            <svg class="icon" viewBox="0 0 24 24" aria-hidden>
              <path d="M14 14.76V6a2 2 0 1 0-4 0v8.76a4 4 0 1 0 4 0z"></path>
            </svg>
            Internal Temperature
          </div>
          <div class="feature-value" id="card_temp_value">-- °C</div>
          <div class="sub">CARCAT internal temperature</div>
        </div>

        <div class="tile" id="card_freq_min" style="border-left:6px solid var(--accent-1)">
          <div class="heading">
            <svg class="icon" viewBox="0 0 24 24" aria-hidden>
              <path d="M4 12h2l2-4 2 8 2-4 2 6 2-10 2 6h2"></path>
            </svg>
            Min Frequency (current)
          </div>
          <div class="feature-value" id="card_minfreq">-- kHz</div>
          <div class="sub">From LIVE packet</div>
        </div>
        <div class="tile" id="card_freq_max" style="border-left:6px solid var(--accent-3)">
          <div class="heading">
            <svg class="icon" viewBox="0 0 24 24" aria-hidden>
              <path d="M3 12h3l2-6 2 12 2-8 2 10 2-14 2 8h2"></path>
            </svg>
            Max Frequency (current)
          </div>
          <div class="feature-value" id="card_maxfreq">-- kHz</div>
          <div class="sub">From LIVE packet</div>
        </div>

        <div class="tile" id="card_wave" style="border-left:6px solid var(--accent-4)">
          <div class="heading">
            <svg class="icon" viewBox="0 0 24 24" aria-hidden>
              <path d="M2 12c4 0 4-8 8-8s4 8 8 8 4 8 8 8"></path>
            </svg>
            Wave velocity (current)
          </div>
          <div class="feature-value" id="card_waveval">--</div>
          <div class="sub">From LIVE packet</div>
        </div>

        <div class="tile" id="card_spectrum" style="border-left:6px solid #8b5cf6">
          <div class="heading">
            <svg class="icon" viewBox="0 0 24 24" aria-hidden>
              <path d="M3 18h2v-6H3zm4 0h2v-4H7zm4 0h2v-8h-2zm4 0h2v-5h-2zm4 0h2v-3h-2zM3 12h2V8H3zm4 0h2V6H7zm4 0h2V4h-2zm4 0h2V9h-2zm4 0h2V7h-2z"></path>
            </svg>
            Spectrum analysis
          </div>
          <div class="radio-group">
            <input type="radio" id="modeFft" name="spectrumMode">
            <label for="modeFft">FFT</label>
            <input type="radio" id="modeWaterfall" name="spectrumMode" checked>
            <label for="modeWaterfall">Waterfall</label>
          </div>
          <canvas id="spectrumCanvas" style="width:100%; height:160px; border-radius:8px; background:var(--card); display:block; margin-top:8px;"></canvas>
          <div style="margin-top:8px; display:flex; justify-content:space-between; gap:4px; font-size:12px;">
            <div><span class="small-muted">Min Freq:</span> <span id="spec_minfreq" style="color:var(--text); font-weight:600;">-- kHz</span></div>
            <div><span class="small-muted">Max Freq:</span> <span id="spec_maxfreq" style="color:var(--text); font-weight:600;">-- kHz</span></div>
            <div><span class="small-muted">Velocity:</span> <span id="spec_wave" style="color:var(--text); font-weight:600;">-- ppm</span></div>
            <div><span class="small-muted">Pattern:</span> <span id="spec_pattern" style="color:var(--text); font-weight:600;">--</span></div>
          </div>
        </div>

        <div class="tile" id="card_pattern" style="border-left:6px solid var(--accent-2)">
          <div class="heading">
            <svg class="icon" viewBox="0 0 24 24" aria-hidden>
              <path d="M6 8c2 0 2-4 4-4s2 4 4 4 2-4 4-4"></path>
            </svg>
            Ultrasound pattern
          </div>
          <div class="feature-value" id="card_pattern_val">--</div>
          <div class="sub">From LIVE packet</div>
        </div>

        <div class="tile" id="card_uptime" style="border-left:6px solid #5b2133">
          <div class="heading">
            <svg class="icon" viewBox="0 0 24 24" aria-hidden>
              <path d="M12 6v6l4 2"></path>
              <circle cx="12" cy="12" r="9"></circle>
            </svg>
            Device UP-Time
          </div>
          <div class="feature-value" id="card_days">-- Days</div>
          <div class="sub" id="card_hhmmss">--:--:-- (HH:MM:SS)</div>
        </div>

        <!-- INIT feature cards -->
        <div class="tile" id="feat_beep_card" style="border-left:6px solid #ff6fa6">
          <div style="display:flex;align-items:center;justify-content:space-between">
            <div>
              <div class="feature-title">
                <svg class="icon" viewBox="0 0 24 24" aria-hidden>
                  <path d="M5 11h4l5-5v12l-5-5H5z"></path>
                </svg>
                Audible beep
              </div>
              <div class="feature-sub">Duration — after every</div>
            </div>
            <div style="display:flex;flex-direction:column;gap:6px;align-items:flex-end">
              <div id="beep_enabled_card" class="muted">Disabled</div>
              <div class="gear" data-feature="beep" title="Edit audible beep">⚙</div>
            </div>
          </div>
          <div style="margin-top:8px;display:flex;justify-content:space-between;align-items:center">
            <div>
              <div class="small-muted">Set value</div>
              <div class="feature-value" id="beep_set">-- s</div>
            </div>
            <div>
              <div class="small-muted">Default</div>
              <div class="small-muted" id="beep_default_card">-- s</div>
            </div>
            <div>
              <div class="small-muted">Slider min/max</div>
              <div class="small-muted" id="beep_minmax">-- / -- s</div>
            </div>
          </div>
        </div>

        <div class="tile" id="feat_standby_card" style="border-left:6px solid #39d0ff">
</div>
<script>
let device = null;
let writeChar = null;
let notifyChar = null;
let autoIntervalId = null;
let currentInitData = null;
let lastPacket = null;
let writeInProgress = false;
let isAnimating = false;
let animationStartTime = 0;
let currentMode = 'waterfall';
let waterfallLines = [];
let currentWavePpm = 0;
let editingFeature = null;
let awaitingInitPromise = null;
let pendingSave = null;
let currentDeviceStatus = "--";

const statusDot = document.createElement('div');
statusDot.style.cssText = 'width:8px;height:8px;border-radius:50%;background:#ff6b6b;display:inline-block;margin-right:8px;';

const deviceName = document.getElementById('deviceName');
const bleText = document.createElement('div');
bleText.style.cssText = 'font-size:12px;color:var(--muted);margin-top:4px;';
bleText.textContent = 'Disconnected';
deviceName.parentNode.appendChild(bleText);

const recvRaw = document.getElementById('recvRaw');
const autoStatus = document.getElementById('autoStatus');
const connectButton = document.getElementById('connectButton');
const disconnectButton = document.getElementById('disconnectButton');
const sendLiveBtn = document.getElementById('sendLiveBtn');
const sendInitBtn = document.getElementById('sendInitBtn');
const startAutoBtn = document.getElementById('startAutoBtn');
const stopAutoBtn = document.getElementById('stopAutoBtn');
const clearRaw = document.getElementById('clearRaw');
const forceParse = document.getElementById('forceParse');

const card_battery = document.getElementById('card_battery');
const card_current_val = document.getElementById('card_current_val');
const card_temp_value = document.getElementById('card_temp_value');
const card_minfreq = document.getElementById('card_minfreq');
const card_maxfreq = document.getElementById('card_maxfreq');
const card_waveval = document.getElementById('card_waveval');
const card_pattern_val = document.getElementById('card_pattern_val');
const card_days = document.getElementById('card_days');
const card_hhmmss = document.getElementById('card_hhmmss');
const spec_minfreq = document.getElementById('spec_minfreq');
const spec_maxfreq = document.getElementById('spec_maxfreq');
const spec_wave = document.getElementById('spec_wave');
const spec_pattern = document.getElementById('spec_pattern');
const card_device_status_val = document.getElementById('card_device_status_val');

const modalBackdrop = document.getElementById('modalBackdrop');
const modalTitle = document.getElementById('modalTitle');
const modalToggle = document.getElementById('modalToggle');
const modalSlider = document.getElementById('modalSlider');
const modalSliderValue = document.getElementById('modalSliderValue');
const sliderLabel = document.getElementById('sliderLabel');
const sliderMinLabel = document.getElementById('sliderMinLabel');
const sliderMaxLabel = document.getElementById('sliderMaxLabel');
const modalReset = document.getElementById('modalReset');
const modalSave = document.getElementById('modalSave');
const modalClose = document.getElementById('modalClose');

const modeFft = document.getElementById('modeFft');
const modeWaterfall = document.getElementById('modeWaterfall');
const spectrumCanvas = document.getElementById('spectrumCanvas');

const CMD_BYTES = {
  beep: [0x49, 0x4E, 0x49, 0x54],
  standby: [0x53, 0x54, 0x42, 0x59],
  shutdown: [0x53, 0x48, 0x55, 0x54],
  hiss: [0x48, 0x49, 0x53, 0x53]
};

function bytesToHexUpper(bytes) {
  return Array.from(bytes, b => ('0' + b.toString(16).toUpperCase()).slice(-2)).join(' ');
}

function isTagAt(arr, offset, tag) {
  const tagBytes = new TextEncoder().encode(tag);
  return arr.length >= offset + tagBytes.length && Array.from(arr.slice(offset, offset + tagBytes.length)).every((b, i) => b === tagBytes[i]);
}

function appendRaw(arr, label = '') {
  const hex = bytesToHexUpper(arr);
  const ts = new Date().toLocaleTimeString();
  const line = `<div>${ts} ${label} [${hex}]</div>`;
  recvRaw.innerHTML += line;
  recvRaw.scrollTop = recvRaw.scrollHeight;
  lastPacket = arr;
}

async function writeFrame(frame, label = '') {
  if (!writeChar) throw new Error("No write characteristic");
  if (writeInProgress) throw new Error("Write in progress");
  writeInProgress = true;
  console.log(`TX ${label}: ${bytesToHexUpper(frame)}`);
  try {
    await writeChar.writeValue(frame);
  } finally {
    writeInProgress = false;
  }
}

async function sendLiveCmd() {
  if (!writeChar) return;
  const frame = new Uint8Array([
    0xFD, 0xFC, 0xFB, 0xFA, 0x04, 0x00,
    0x4C, 0x49, 0x56, 0x45,
    0x04, 0x03, 0x02, 0x01
  ]);
  await writeFrame(frame, 'LIVE');
}

async function sendInitCmd() {
  if (!writeChar) return;
  const frame = new Uint8Array([
    0xFD, 0xFC, 0xFB, 0xFA, 0x04, 0x00,
    0x49, 0x4E, 0x49, 0x54,
    0x04, 0x03, 0x02, 0x01
  ]);
  await writeFrame(frame, 'INIT');
}

function parseLivePacket(buffer) {
  if (buffer.length < 33) return { error: "LIVE packet too short (need ≥33 bytes)" };
  const view = new DataView(buffer.buffer);
  const dataLen = view.getUint16(4, true);
  if (dataLen !== 23) return { error: `Invalid LIVE data length: ${dataLen} (expected 23)` };

  const battery_mv = view.getUint16(10, true);
  const current_ua = view.getUint16(12, true);
  const temp_c_times100 = view.getUint16(14, true);
  const min_hz_times1000 = view.getUint16(16, true);
  const max_hz_times1000 = view.getUint16(18, true);
  const wave_ppm = view.getUint16(20, true);
  const pattern_enum = buffer[22];
  const device_status_enum = buffer[23];
  const days = view.getUint16(24, true);
  const hh = buffer[26];
  const mm = buffer[27];
  const ss = buffer[28];

  const statusNames = ["Idle mode", "Run mode", "Shutdown mode", "Standby mode"];
  const deviceStatusStr = statusNames[device_status_enum] || `Unknown (${device_status_enum})`;

  const patternNames = ["Continuous", "Pulse", "Sweep", "Zig-Zag"];
  const patternStr = patternNames[pattern_enum] || `Unknown (${pattern_enum})`;

  return {
    battery_v: (battery_mv / 1000).toFixed(2),
    current_ma: (current_ua / 1000).toFixed(2),
    temp_c: (temp_c_times100 / 100).toFixed(0),
    min_khz: (min_hz_times1000 / 1000 / 1000).toFixed(1),
    max_khz: (max_hz_times1000 / 1000 / 1000).toFixed(1),
    wave_ppm,
    pattern: patternStr,
    deviceStatus: deviceStatusStr,
    uptime: `${days} Days ${hh.toString().padStart(2,'0')}:${mm.toString().padStart(2,'0')}:${ss.toString().padStart(2,'0')} (HH:MM:SS)`,
    _rawBuf: buffer
  };
}

function showLive(data) {
  card_battery.textContent = data.battery_v;
  card_current_val.textContent = data.current_ma;
  card_temp_value.textContent = data.temp_c;
  card_minfreq.textContent = data.min_khz;
  card_maxfreq.textContent = data.max_khz;
  card_waveval.textContent = data.wave_ppm;
  card_pattern_val.textContent = data.pattern;
  card_device_status_val.textContent = data.deviceStatus;
  card_days.textContent = data.uptime.split(' ')[0] + ' Days';
  card_hhmmss.textContent = data.uptime.split(' ').slice(1).join(' ');

  spec_minfreq.textContent = data.min_khz + ' kHz';
  spec_maxfreq.textContent = data.max_khz + ' kHz';
  spec_wave.textContent = data.wave_ppm + ' ppm';
  spec_pattern.textContent = data.pattern;

  currentWavePpm = data.wave_ppm;
  if (currentWavePpm > 0 && !isAnimating) {
    isAnimating = true;
    animationStartTime = performance.now();
    requestAnimationFrame(animateSpectrum);
  }
}

function parseInitPacket(buffer) {
  if (buffer.length < 51) return { error: "INIT packet too short" };
  const view = new DataView(buffer.buffer);
  const dataLen = view.getUint16(4, true);
  if (dataLen !== 40) return { error: `Invalid INIT data length: ${dataLen}` };

  // Parse features (simplified; assume fixed offsets for each 10-byte feature block)
  const features = {};
  let offset = 10; // After echo and ack byte

  // Beep: bytes 10-19
  features.beep = {
    enabled: buffer[offset] === 1,
    value: view.getUint16(offset + 1, true),
    def: view.getUint16(offset + 3, true),
    min: view.getUint16(offset + 5, true),
    max: view.getUint16(offset + 7, true)
  };

  // Standby: bytes 20-29
  offset += 10;
  features.standby = {
    enabled: buffer[offset] === 1,
    value_mV: view.getUint16(offset + 1, true),
    def_mV: view.getUint16(offset + 3, true),
    min_mV: view.getUint16(offset + 5, true),
    max_mV: view.getUint16(offset + 7, true)
  };

  // Shutdown: bytes 30-39
  offset += 10;
  features.shutdown = {
    enabled: buffer[offset] === 1,
    value_mV: view.getUint16(offset + 1, true),
    def_mV: view.getUint16(offset + 3, true),
    min_mV: view.getUint16(offset + 5, true),
    max_mV: view.getUint16(offset + 7, true)
  };

  // Hiss: bytes 40-49
  offset += 10;
  features.hiss = {
    enabled: buffer[offset] === 1,
    value_pct: view.getUint16(offset + 1, true),
    def_pct: view.getUint16(offset + 3, true),
    min_pct: view.getUint16(offset + 5, true),
    max_pct: view.getUint16(offset + 7, true)
  };

  return { ...features, _rawBuf: buffer };
}

function showInit(data) {
  currentInitData = data;

  // Update beep card
  const beep = data.beep;
  document.getElementById('beep_enabled_card').textContent = beep.enabled ? 'Enabled' : 'Disabled';
  document.getElementById('beep_set').textContent = beep.value + ' s';
  document.getElementById('beep_default_card').textContent = beep.def + ' s';
  document.getElementById('beep_minmax').textContent = beep.min + ' / ' + beep.max + ' s';

  // Update standby card (example; add others similarly if needed)
  // ...
}

function animateSpectrum(now) {
  const canvas = spectrumCanvas;
  const ctx = canvas.getContext('2d');
  const rect = canvas.getBoundingClientRect();
  canvas.width = rect.width * window.devicePixelRatio;
  canvas.height = rect.height * window.devicePixelRatio;
  ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

  const width = canvas.width / window.devicePixelRatio;
  const height = canvas.height / window.devicePixelRatio;

  ctx.fillStyle = 'rgba(15, 17, 20, 0.1)';
  ctx.fillRect(0, 0, width, height);

  const elapsed = (now - animationStartTime) / 1000;
  const numPoints = 100;
  const freqRange = parseFloat(card_maxfreq.textContent) - parseFloat(card_minfreq.textContent);
  const timeFactor = Math.sin(elapsed * currentWavePpm / 1000) * 0.5 + 0.5;

  if (currentMode === 'fft') {
    // Simplified FFT-like bars
    for (let i = 0; i < numPoints; i++) {
      const freq = parseFloat(card_minfreq.textContent) + (i / numPoints) * freqRange;
      const amp = Math.random() * 50 + timeFactor * 100;
      const barHeight = (amp / 100) * height;
      ctx.fillStyle = `hsl(${i * 360 / numPoints}, 70%, 50%)`;
      ctx.fillRect(i * width / numPoints, height - barHeight, width / numPoints, barHeight);
    }
  } else {
    // Waterfall: shift down, add new line
    waterfallLines.unshift(new Array(numPoints).fill(0).map((_, i) => Math.random() * 255));
    if (waterfallLines.length > height) waterfallLines.pop();

    for (let y = 0; y < height; y++) {
      const line = waterfallLines[y] || new Array(numPoints).fill(0);
      for (let x = 0; x < numPoints; x++) {
        const val = line[x];
        ctx.fillStyle = `hsl(240, 100%, ${val}%)`;
        ctx.fillRect(x * width / numPoints, y, width / numPoints, 1);
      }
    }

    // Add new line at top with time-based variation
    const newLine = new Array(numPoints).fill(0).map((_, i) => {
      const freq = parseFloat(card_minfreq.textContent) + (i / numPoints) * freqRange;
      return (Math.sin(elapsed * freq / 1000) * 0.5 + 0.5) * 255 * timeFactor;
    });
    for (let x = 0; x < numPoints; x++) {
      const val = newLine[x];
      ctx.fillStyle = `hsl(240, 100%, ${val}%)`;
      ctx.fillRect(x * width / numPoints, 0, width / numPoints, 1);
    }
  }

  if (isAnimating) requestAnimationFrame(animateSpectrum);
}

async function connect() {
  try {
    device = await navigator.bluetooth.requestDevice({
      filters: [{ services: ['6e400001-b5a3-f393-e0a9-e50e24dcca9e'] }],
      optionalServices: ['6e400001-b5a3-f393-e0a9-e50e24dcca9e']
    });
    deviceName.textContent = device.name || device.id.slice(-4);
    bleText.textContent = 'Connecting...';
    statusDot.style.background = '#ffd54a';

    device.addEventListener('gattserverdisconnected', onDeviceDisconnected);
    const server = await device.gatt.connect();
    const service = await server.getPrimaryService('6e400001-b5a3-f393-e0a9-e50e24dcca9e');
    writeChar = await service.getCharacteristic('6e400002-b5a3-f393-e0a9-e50e24dcca9e');
    notifyChar = await service.getCharacteristic('6e400003-b5a3-f393-e0a9-e50e24dcca9e');

    await notifyChar.startNotifications();
    notifyChar.addEventListener('characteristicvaluechanged', onNotify);

    bleText.textContent = 'Connected';
    statusDot.style.background = '#27b56b';

    connectButton.disabled = true;
    disconnectButton.disabled = false;
    sendLiveBtn.disabled = false;
    sendInitBtn.disabled = false;
    startAutoBtn.disabled = false;
    stopAutoBtn.disabled = true;
  } catch (error) {
    console.error('Connection failed:', error);
    bleText.textContent = 'Failed';
    statusDot.style.background = '#ff6b6b';
    alert('Connection failed: ' + error.message);
  }
}

function onDeviceDisconnected(event) {
  const dev = event?.target;
  console.log("Device disconnected:", dev ? (dev.name || dev.id) : dev);
  stopAutoLive();
  isAnimating = false;
  deviceName.textContent = "Not connected";
  bleText.textContent = "Disconnected";
  statusDot.style.background = "#ff6b6b";

  connectButton.disabled = false;
  disconnectButton.disabled = true;
  sendLiveBtn.disabled = true;
  sendInitBtn.disabled = true;
  startAutoBtn.disabled = true;
  stopAutoBtn.disabled = true;
}

async function disconnect() {
  stopAutoLive();
  isAnimating = false;
  try {
    if (device) {
      console.log("Disconnect requested for device:", device.name || device.id);
      if (device.gatt && device.gatt.connected) {
        device.gatt.disconnect();
        console.log("Device gatt.disconnect() called");
      } else {
        console.log("Device was already disconnected.");
      }
    }
  } catch (e) {
    console.error("Error during disconnect:", e);
  } finally {
    deviceName.textContent = "Not connected";
    bleText.textContent = "Disconnected";
    statusDot.style.background = "#ff6b6b";

    connectButton.disabled = false;
    disconnectButton.disabled = true;
    sendLiveBtn.disabled = true;
    sendInitBtn.disabled = true;
    startAutoBtn.disabled = true;
    stopAutoBtn.disabled = true;
  }
}

/* Notify handler: resolves awaitingInitPromise and pendingSave appropriately */
function onNotify(ev){
  const arr = new Uint8Array(ev.target.value.buffer);

  if (isTagAt(arr, 6, "LIVE") && arr.length >= 33) {
    appendRaw(arr, 'LIVE');
    const liveParsed = parseLivePacket(arr);
    if (!liveParsed.error) showLive(liveParsed);
    return;
  }

  if (isTagAt(arr, 6, "INIT") && arr.length >= 51) {
    appendRaw(arr, 'INIT');
    const initParsed = parseInitPacket(arr);
    if (!initParsed.error) {
      showInit(initParsed);

      // resolve any waiting gear -> INIT request
      try {
        if (awaitingInitPromise && typeof awaitingInitPromise._resolve === 'function') {
          awaitingInitPromise._resolve(initParsed);
          awaitingInitPromise = null;
        }
      } catch (e) { console.warn("Error resolving awaitingInitPromise", e); }

      // check pending save ack (byte index 10 == 1)
      try {
        const buf = initParsed._rawBuf;
        if (pendingSave && buf && buf.length > 10 && buf[10] === 1) {
          console.log("ACK INIT received (byte10==1) for pending save");
          pendingSave.resolve({ feature: pendingSave.feature, value: pendingSave.value, buf });
          pendingSave = null;
        }
      } catch (e) { console.warn("ack check error", e); }
    }
    return;
  }

  appendRaw(arr, '');
}

/* Auto LIVE */
function startAutoLive(){
  if(autoIntervalId) return;
  if(!writeChar){ alert("Not connected"); return; }
  autoStatus.textContent = "Auto ON";
  startAutoBtn.disabled = true;
  stopAutoBtn.disabled = false;
  autoIntervalId = setInterval(()=>{ if(!writeInProgress) sendLiveCmd(); },500);
}
function stopAutoLive(){
  if(autoIntervalId) clearInterval(autoIntervalId);
  autoIntervalId = null;
  autoStatus.textContent = "Idle";
  startAutoBtn.disabled = false;
  stopAutoBtn.disabled = true;
}

/* waitForNextInit — used when gear pressed and we need to request INIT and wait for it */
function waitForNextInit(timeoutMs = 3000) {
  if (awaitingInitPromise) return awaitingInitPromise;
  let timer;
  awaitingInitPromise = new Promise((resolve, reject) => {
    timer = setTimeout(() => {
      awaitingInitPromise = null;
      reject(new Error("INIT timeout"));
    }, timeoutMs);
    awaitingInitPromise._resolve = (initParsed) => {
      clearTimeout(timer);
      awaitingInitPromise = null;
      resolve(initParsed);
    };
  });
  return awaitingInitPromise;
}

/* WAIT-for-ACK logic: create pendingSave inside waitForInitAck */
function waitForInitAck(feature, value, timeoutMs = 5000){
  if(pendingSave) throw new Error("pendingSave already exists");
  return new Promise((resolve, reject) => {
    const timer = setTimeout(() => {
      if (pendingSave) pendingSave = null;
      reject(new Error("timeout"));
    }, timeoutMs);

    pendingSave = {
      feature,
      value,
      resolve: (info) => { clearTimeout(timer); pendingSave = null; resolve(info); },
      reject: (err) => { clearTimeout(timer); pendingSave = null; reject(err); }
    };
  });
}

/* build & send save frame, then wait for INIT ack */
async function performSaveWrite(featureKey, enabledNow, sliderRaw){
  if(!writeChar) throw new Error("Not connected");
  if(writeInProgress) throw new Error("Write in progress");
  const cmd = CMD_BYTES[featureKey];
  if(!cmd) throw new Error("Unknown feature cmd");

  const frame = new Uint8Array(4 + 2 + 4 + 1 + 2 + 4);
  let p = 0;
  frame[p++] = 0xFD; frame[p++] = 0xFC; frame[p++] = 0xFB; frame[p++] = 0xFA;
  frame[p++] = 0x07; frame[p++] = 0x00;
  frame[p++] = cmd[0]; frame[p++] = cmd[1]; frame[p++] = cmd[2]; frame[p++] = cmd[3];
  frame[p++] = enabledNow & 0xFF;
  frame[p++] = sliderRaw & 0xFF;
  frame[p++] = (sliderRaw >> 8) & 0xFF;
  frame[p++] = 0x04; frame[p++] = 0x03; frame[p++] = 0x02; frame[p++] = 0x01;

  console.log(`TX SAVE [${featureKey}] (EN=${enabledNow}) : ${bytesToHexUpper(frame)}`);

  // write the frame first
  await writeFrame(frame, `SAVE-${featureKey}`);

  // then wait for INIT ack — this will create pendingSave and wait for onNotify to resolve it
  return waitForInitAck(featureKey, sliderRaw, 5000);
}

/* modal helpers */
function updateModalSliderValueDisplaySeconds(){ modalSliderValue.textContent = modalSlider.value + " s"; }
function updateModalSliderValueDisplayVolts(){ modalSliderValue.textContent = (modalSlider.value/1000).toFixed(3) + " V"; }
function updateModalSliderValueDisplayPercent(){ modalSliderValue.textContent = modalSlider.value + " %"; }

function openFeatureModal(featureKey){
  if(!currentInitData) return alert("No INIT data available yet. Send INIT to populate.");
  const data = currentInitData[featureKey];
  if(!data) return alert("Feature data missing");
  editingFeature = featureKey;
  modalTitle.textContent = ({beep:"Audible beep", standby:"Standby mode", shutdown:"Shutdown mode", hiss:"Audible Hiss band"})[featureKey] || "Edit Feature";
  if(data.enabled) modalToggle.classList.add('on'); else modalToggle.classList.remove('on');

  if(featureKey === 'beep'){
    modalSlider.min = data.min ?? 0; modalSlider.max = data.max ?? Math.max((data.min||0)+1, data.value||0);
    modalSlider.step = 1; modalSlider.value = data.value ?? data.def ?? modalSlider.min;
    sliderLabel.textContent = "Duration - (after every)";
    sliderMinLabel.textContent = modalSlider.min + " s"; sliderMaxLabel.textContent = modalSlider.max + " s";
    updateModalSliderValueDisplaySeconds();
  } else if(featureKey === 'standby' || featureKey === 'shutdown'){
    const rawMin = data.min_mV ?? 0; const rawMax = data.max_mV ?? Math.max(rawMin+1, data.value_mV||0);
    modalSlider.min = rawMin; modalSlider.max = rawMax; modalSlider.step = 1;
    modalSlider.value = data.value_mV ?? data.def_mV ?? modalSlider.min;
    sliderLabel.textContent = featureKey === 'standby' ? "Charging voltage threshold" : "Cut-off voltage";
    sliderMinLabel.textContent = (rawMin/1000).toFixed(3) + " V"; sliderMaxLabel.textContent = (rawMax/1000).toFixed(3) + " V";
    updateModalSliderValueDisplayVolts();
  } else if(featureKey === 'hiss'){
    modalSlider.min = data.min_pct ?? 0; modalSlider.max = data.max_pct ?? Math.max((data.min_pct||0)+1, data.value_pct||0);
    modalSlider.step = 1; modalSlider.value = data.value_pct ?? data.def_pct ?? modalSlider.min;
    sliderLabel.textContent = "Play frequency (band %)";
    sliderMinLabel.textContent = modalSlider.min + " %"; sliderMaxLabel.textContent = modalSlider.max + " %";
    updateModalSliderValueDisplayPercent();
  }
  modalBackdrop.style.display = 'flex';
}
modalToggle.addEventListener('click', ()=> modalToggle.classList.toggle('on'));
modalSlider.addEventListener('input', ()=>{
  if(!editingFeature) return;
  if(editingFeature === 'beep') updateModalSliderValueDisplaySeconds();
  else if(editingFeature === 'standby' || editingFeature === 'shutdown') updateModalSliderValueDisplayVolts();
  else if(editingFeature === 'hiss') updateModalSliderValueDisplayPercent();
});
modalReset.addEventListener('click', ()=>{
  if(!editingFeature || !currentInitData) return;
  const d = currentInitData[editingFeature];
  if(!d) return;
  if(d.en_default) modalToggle.classList.add('on'); else modalToggle.classList.remove('on');
  if(editingFeature === 'beep'){ modalSlider.value = (d.def!=null)?d.def:(d.value!=null?d.value:modalSlider.min); updateModalSliderValueDisplaySeconds(); }
  else if(editingFeature === 'standby' || editingFeature === 'shutdown'){ modalSlider.value = (d.def_mV!=null)?d.def_mV:(d.value_mV!=null?d.value_mV:modalSlider.min); updateModalSliderValueDisplayVolts(); }
  else if(editingFeature === 'hiss'){ modalSlider.value = (d.def_pct!=null)?d.def_pct:(d.value_pct!=null?d.value_pct:modalSlider.min); updateModalSliderValueDisplayPercent(); }
});
modalClose.addEventListener('click', closeModal);
modalBackdrop.addEventListener('click', (ev)=>{ if(ev.target === modalBackdrop) closeModal(); });
function closeModal(){ modalBackdrop.style.display = 'none'; editingFeature = null; }

/* modal save uses performSaveWrite (which waits for ACK) */
modalSave.addEventListener('click', async ()=>{
  if(!editingFeature || !currentInitData){ closeModal(); return; }
  if(!writeChar) { alert("Not connected — can't send save command"); return; }
  if(writeInProgress) { alert("Write in progress — try again"); return; }

  const enabledNow = modalToggle.classList.contains('on') ? 1 : 0;
  const sliderRaw = parseInt(modalSlider.value,10);
  modalSave.disabled = true; const prevText = modalSave.textContent; modalSave.textContent = "Saving...";
  try{
    await performSaveWrite(editingFeature, enabledNow, sliderRaw);
    // On ACK success update local model & UI
    if(editingFeature === 'beep'){ currentInitData.beep.enabled = enabledNow===1; currentInitData.beep.value = sliderRaw; }
    else if(editingFeature === 'standby'){ currentInitData.standby.enabled = enabledNow===1; currentInitData.standby.value_mV = sliderRaw; }
    else if(editingFeature === 'shutdown'){ currentInitData.shutdown.enabled = enabledNow===1; currentInitData.shutdown.value_mV = sliderRaw; }
    else if(editingFeature === 'hiss'){ currentInitData.hiss.enabled = enabledNow===1; currentInitData.hiss.value_pct = sliderRaw; }
    showInit(currentInitData);
    closeModal();
    alert("Save acknowledged (INIT byte10=1).");
  }catch(e){
    console.warn("Save ACK error:", e);
    alert("No response received (timeout). Save not acknowledged.");
  }finally{
    modalSave.disabled = false; modalSave.textContent = prevText; pendingSave = null;
  }
});

/* gear button wiring */
document.querySelectorAll('.gear').forEach(g => {
  g.addEventListener('click', async () => {
    const feature = g.dataset.feature;
    if (currentInitData) { openFeatureModal(feature); return; }
    if (!writeChar) { alert("Not connected. Please connect before editing features."); return; }
    try {
      console.log("No INIT cached — sending INIT request before opening modal");
      await sendInitCmd();
      const initParsed = await waitForNextInit(3000); // 3s
      console.log("Received INIT after request:", initParsed);
      openFeatureModal(feature);
    } catch (err) {
      console.warn("Failed to get INIT before opening modal:", err);
      alert("Could not get INIT from device. Try sending INIT manually or try again.");
    }
  });
});

/* UI wiring for other controls */
connectButton.addEventListener('click', connect);
disconnectButton.addEventListener('click', disconnect);
sendLiveBtn.addEventListener('click', sendLiveCmd);
sendInitBtn.addEventListener('click', sendInitCmd);
startAutoBtn.addEventListener('click', startAutoLive);
stopAutoBtn.addEventListener('click', stopAutoLive);
clearRaw.addEventListener('click', ()=> recvRaw.innerHTML = '');
forceParse.addEventListener('click', ()=>{
  if(!lastPacket) return alert("No packet available");
  if(!isTagAt(lastPacket, 6, "LIVE")) return alert("Latest packet does not have 'LIVE' at bytes 6..9 — parsing skipped.");
  if(lastPacket.length < 33) return alert("LIVE packet too short (need ≥33 bytes).");
  const parsed = parseLivePacket(lastPacket);
  if(parsed.error) alert(parsed.error); else showLive(parsed);
});
document.getElementById('copyParsed').addEventListener('click', async ()=>{
  const lines = [
    `Battery (V): ${card_battery.textContent}`,
    `Current (mA): ${card_current_val.textContent}`,
    `Temp (°C): ${card_temp_value.textContent}`,
    `Min(kHz): ${card_minfreq.textContent}`,
    `Max(kHz): ${card_maxfreq.textContent}`
  ].join("\n");
  await navigator.clipboard.writeText(lines); alert("LIVE parsed copied");
});
document.getElementById('copyInit').addEventListener('click', async ()=>{ if(!currentInitData) return alert("No INIT"); await navigator.clipboard.writeText(JSON.stringify(currentInitData,null,2)); alert("INIT copied"); });

/* Spectrum mode switching */
modeFft.addEventListener('change', () => {
  if (modeFft.checked) {
    currentMode = 'fft';
    if (currentWavePpm > 0 && !isAnimating) {
      isAnimating = true;
      animationStartTime = performance.now();
      requestAnimationFrame(animateSpectrum);
    }
  }
});
modeWaterfall.addEventListener('change', () => {
  if (modeWaterfall.checked) {
    currentMode = 'waterfall';
    waterfallLines = []; // Reset buffer
    if (currentWavePpm > 0 && !isAnimating) {
      isAnimating = true;
      animationStartTime = performance.now();
      requestAnimationFrame(animateSpectrum);
    }
  }
});

/* initial checks */
if(!navigator.bluetooth){
  alert("Web Bluetooth not available in this browser.");
  connectButton.disabled = true;
  startAutoBtn.disabled = true;
  sendInitBtn.disabled = true;
  stopAutoBtn.disabled = true;
}

/* Handle canvas resize */
window.addEventListener('resize', () => {
  if (isAnimating) {
    animationStartTime = performance.now();
    requestAnimationFrame(animateSpectrum);
  }
});
</script>
</body>
</html>
