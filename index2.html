<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Web BLE Variable Binary Transfer</title>
    <style>
      body { font-family: Arial, sans-serif; margin: 20px; }
      button { padding: 8px 14px; margin: 5px; }
      input, textarea { padding: 8px; margin: 5px; }
      input[type="number"] { width: 120px; }
      textarea { width: 100%; height: 120px; resize: vertical; }
      #log, #recvLog { border: 1px solid #ccc; padding: 10px; height: 180px; overflow-y: auto; background:#fafafa; }
      #sendProgress, #receiveProgress { width: 100%; height: 20px; margin-top: 10px; }
      .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
      .col { display:flex; flex-direction:column; gap:6px; }
      .small { font-size:0.9rem; color:#444 }
      .mono { font-family: "Courier New", Courier, monospace; font-size:0.95rem; }
    </style>
  </head>
  <body>
    <h2>Web BLE Variable Binary Transfer with Docklight</h2>
    <p class="small">Current Time: 09:17 PM IST, Monday, June 02, 2025</p>

    <div class="row">
      <button id="connectButton">Connect to HLK-B40</button>
      <button id="disconnectButton" disabled>Disconnect</button>
    </div>

    <hr />

    <div class="col">
      <div class="row">
        <input id="byteCountInput" type="number" placeholder="Bytes to send" min="1" value="5000" />
        <button id="sendBinaryButton" disabled>Send Binary Data</button>
      </div>

      <h4>Send Custom Docklight Hex</h4>
      <div class="row">
        <input id="hexInput" type="text" placeholder="e.g. FD FC FB FA 04 00 4C 49 56 45 04 03 02 01" style="flex:1" />
        <button id="sendHexButton" disabled>Send Hex</button>
        <button id="pasteExample">Paste Example</button>
      </div>

      <div class="row">
        <button id="liveButton" disabled>LIVE (embedded)</button>
        <button id="initButton" disabled>INIT (embedded)</button>
        <button id="clearSendLog">Clear Send Log</button>
      </div>

      <h4>Send Progress</h4>
      <progress id="sendProgress" value="0" max="100"></progress>
    </div>

    <hr />

    <div class="col">
      <h4>Receive (Docklight hex format)</h4>
      <div class="row">
        <progress id="receiveProgress" value="0" max="100" style="flex:1"></progress>
        <button id="clearRecvLog">Clear Receive Log</button>
      </div>
      <div id="recvLog" class="mono"></div>
    </div>

    <hr />

    <div class="col">
      <h3>Send Log</h3>
      <div id="log" class="mono"></div>
    </div>

    <script>
      // UUIDs and settings (unchanged)
      const serviceUuid = "0000fff0-0000-1000-8000-00805f9b34fb";
      const notifyCharUuid = "0000fff1-0000-1000-8000-00805f9b34fb";
      const writeCharUuid = "0000fff2-0000-1000-8000-00805f9b34fb";
      const maxWriteSize = 512; // Web Bluetooth API limit for writeValue

      // Embedded commands (exact bytes requested)
      const LIVE_CMD_HEX = "FD FC FB FA 04 00 4C 49 56 45 04 03 02 01";
      const INIT_CMD_HEX = "FD FC FB FA 04 00 49 4E 49 54 04 03 02 01";

      let device, notifyCharacteristic, writeCharacteristic;
      let receiveBuffer = [];
      let receivedBytes = 0;
      let expectedReceiveBytes = 3072; // Set based on your test (3 Ã— 1024)

      // DOM
      const connectButton = document.getElementById("connectButton");
      const disconnectButton = document.getElementById("disconnectButton");
      const sendBinaryButton = document.getElementById("sendBinaryButton");
      const byteCountInput = document.getElementById("byteCountInput");
      const logDiv = document.getElementById("log");
      const recvLogDiv = document.getElementById("recvLog");
      const sendProgressBar = document.getElementById("sendProgress");
      const receiveProgressBar = document.getElementById("receiveProgress");

      const hexInput = document.getElementById("hexInput");
      const sendHexButton = document.getElementById("sendHexButton");
      const liveButton = document.getElementById("liveButton");
      const initButton = document.getElementById("initButton");
      const pasteExample = document.getElementById("pasteExample");
      const clearSendLog = document.getElementById("clearSendLog");
      const clearRecvLog = document.getElementById("clearRecvLog");

      function log(message) {
        const time = new Date().toLocaleTimeString();
        logDiv.innerHTML += `[${time}] ${message}<br>`;
        logDiv.scrollTop = logDiv.scrollHeight;
      }

      function recvLog(message) {
        const time = new Date().toLocaleTimeString();
        recvLogDiv.innerHTML += `[${time}] ${message}<br>`;
        recvLogDiv.scrollTop = recvLogDiv.scrollHeight;
      }

      function bytesToHexUpper(bytes) {
        return Array.from(bytes).map(b => b.toString(16).padStart(2, "0").toUpperCase()).join(" ");
      }

      // Parse Docklight-style hex string to Uint8Array
      function parseHexInput(str) {
        if (!str) return null;
        // remove common separators (spaces, commas, 0x) and non-hex chars
        const cleaned = str.replace(/0x/g, "").replace(/[^a-fA-F0-9]/g, "");
        if (cleaned.length === 0) return null;
        if (cleaned.length % 2 !== 0) {
          // odd length -> invalid
          return { error: "Hex string has odd length (incomplete byte)." };
        }
        const bytes = new Uint8Array(cleaned.length / 2);
        for (let i = 0; i < cleaned.length; i += 2) {
          bytes[i / 2] = parseInt(cleaned.substr(i, 2), 16);
        }
        return { bytes };
      }

      async function connectToDevice() {
        try {
          log("Requesting Bluetooth device...");
          device = await navigator.bluetooth.requestDevice({
            filters: [{ namePrefix: "CARCAT" }, { name: "CARCAT_5G" }],
            optionalServices: [serviceUuid],
          });

          log("Connecting to GATT server...");
          const server = await device.gatt.connect();

          log("Getting primary service...");
          const service = await server.getPrimaryService(serviceUuid);

          log("Getting notify characteristic...");
          notifyCharacteristic = await service.getCharacteristic(notifyCharUuid);

          log("Getting write characteristic...");
          writeCharacteristic = await service.getCharacteristic(writeCharUuid);

          log("Starting notifications...");
          await notifyCharacteristic.startNotifications();
          notifyCharacteristic.addEventListener("characteristicvaluechanged", handleNotifications);

          device.addEventListener("gattserverdisconnected", () => {
            log("Device disconnected.");
            setConnectedState(false);
            receiveBuffer = [];
            receivedBytes = 0;
            receiveProgressBar.value = 0;
          });

          log("Connected to device!");
          setConnectedState(true);
        } catch (error) {
          log("Error: " + error);
        }
      }

      function setConnectedState(connected) {
        connectButton.disabled = connected;
        disconnectButton.disabled = !connected;
        sendBinaryButton.disabled = !connected;
        sendHexButton.disabled = !connected;
        liveButton.disabled = !connected;
        initButton.disabled = !connected;
      }

      // Disconnect button
      disconnectButton.addEventListener("click", async () => {
        if (device && device.gatt.connected) {
          device.gatt.disconnect();
        } else {
          log("No device connected.");
        }
      });

      // Notifications handler
      function handleNotifications(event) {
        const value = new Uint8Array(event.target.value.buffer);
        receiveBuffer.push(...value);
        receivedBytes += value.length;

        const hex = bytesToHexUpper(value);
        recvLog(hex + ` (${value.length} bytes, total: ${receivedBytes})`);
        receiveProgressBar.value = receivedBytes;
        if (receivedBytes >= expectedReceiveBytes) {
          recvLog(`Received all expected ${expectedReceiveBytes} bytes.`);
          receivedBytes = 0;
          receiveProgressBar.value = 0;
          receiveBuffer = [];
        }
      }

      // Send binary (existing)
      async function sendBinaryData() {
        if (!writeCharacteristic) { log("Not connected to a device."); return; }

        const numBytes = parseInt(byteCountInput.value, 10);
        if (isNaN(numBytes) || numBytes < 1) { log("Please enter a valid number of bytes."); return; }

        const data = new Uint8Array(numBytes);
        for (let i = 0; i < numBytes; i++) data[i] = i % 256;

        log(`Sending ${numBytes} bytes...`);
        let bytesSent = 0;
        sendProgressBar.value = 0;
        sendProgressBar.max = numBytes;

        for (let i = 0; i < data.length; i += maxWriteSize) {
          const chunk = data.slice(i, i + maxWriteSize);
          try {
            await writeCharacteristic.writeValue(chunk);
            bytesSent += chunk.length;
            sendProgressBar.value = bytesSent;
            log(`Sent chunk ${chunk.length} bytes (${bytesSent}/${numBytes})`);
            // small pause to avoid overwhelming BLE stack
            await new Promise((r) => setTimeout(r, 20));
          } catch (error) {
            log("Error sending chunk: " + error);
            return;
          }
        }
        log(`Successfully sent ${numBytes} bytes.`);
      }

      // Send arbitrary hex bytes from text input
      async function sendHexFromInput(hexStr) {
        if (!writeCharacteristic) { log("Not connected to a device."); return; }
        const parsed = parseHexInput(hexStr);
        if (!parsed) { log("No hex data provided."); return; }
        if (parsed.error) { log("Hex parse error: " + parsed.error); return; }

        const data = parsed.bytes;
        log(`Sending ${data.length} bytes (hex): ${bytesToHexUpper(data)}`);
        let bytesSent = 0;
        sendProgressBar.value = 0;
        sendProgressBar.max = data.length;

        for (let i = 0; i < data.length; i += maxWriteSize) {
          const chunk = data.slice(i, i + maxWriteSize);
          try {
            await writeCharacteristic.writeValue(chunk);
            bytesSent += chunk.length;
            sendProgressBar.value = bytesSent;
            log(`Sent chunk ${chunk.length} bytes (${bytesSent}/${data.length})`);
            await new Promise((r) => setTimeout(r, 20));
          } catch (error) {
            log("Error sending chunk: " + error);
            return;
          }
        }
        log(`Finished sending ${data.length} bytes.`);
      }

      // Button handlers
      connectButton.addEventListener("click", connectToDevice);
      sendBinaryButton.addEventListener("click", sendBinaryData);

      sendHexButton.addEventListener("click", async () => {
        await sendHexFromInput(hexInput.value);
      });

      liveButton.addEventListener("click", async () => {
        await sendHexFromInput(LIVE_CMD_HEX);
      });

      initButton.addEventListener("click", async () => {
        await sendHexFromInput(INIT_CMD_HEX);
      });

      pasteExample.addEventListener("click", () => {
        hexInput.value = LIVE_CMD_HEX;
      });

      clearSendLog.addEventListener("click", () => { logDiv.innerHTML = ""; });
      clearRecvLog.addEventListener("click", () => { recvLogDiv.innerHTML = ""; });

      // allow Enter key on hex input to send
      hexInput.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          if (!sendHexButton.disabled) sendHexButton.click();
        }
      });

      // Set receive progress bar max based on expected bytes
      receiveProgressBar.max = expectedReceiveBytes;

      // safety: if Bluetooth not supported
      if (!navigator.bluetooth) {
        log("Web Bluetooth API is NOT available in this browser.");
        connectButton.disabled = true;
      }
    </script>
  </body>
</html>
