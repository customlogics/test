<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>CARCAT 5G — Dashboard (BLE + Waterfall)</title>
<style>
  :root{
    --bg: #0b0f14;
    --card: #12202a;
    --text: #ffffff;
    --muted: #9fb0c0;
    --accent-1: #27b56b;
    --accent-2: #3b82f6;
    --icon-yellow: #FFD54A;
  }
  html,body{height:100%;margin:0;font-family:Inter, "Segoe UI", Roboto, Arial; background:linear-gradient(180deg,#06070a 0%, #071018 100%); color:var(--text);}
  .wrap{max-width:1180px;margin:18px auto;padding:18px;display:grid;grid-template-columns:360px 1fr;gap:18px;}
  .left{display:flex;flex-direction:column;gap:18px;}
  .hero{background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:12px;padding:18px;border-left:6px solid var(--accent-1);}
  .hero h1{margin:0;font-size:20px;color:var(--icon-yellow)}
  .muted{color:var(--muted);font-size:13px}
  .raw{background:rgba(255,255,255,0.02);padding:8px;border-radius:8px;font-family:monospace;color:#bfe9d7;height:130px;overflow:auto;border:1px solid rgba(255,255,255,0.03)}
  .btn{padding:8px 12px;border-radius:10px;border:none;background:#2a9df4;color:#021827;cursor:pointer;font-weight:700}
  .ghost{background:transparent;border:1px solid rgba(255,255,255,0.05);color:var(--muted);padding:8px 10px;border-radius:8px;cursor:pointer}
  .grid{display:grid;grid-template-columns:repeat(2,1fr);gap:14px;}
  .tile{background:var(--card); border-radius:12px; padding:16px; position:relative; overflow:hidden; box-shadow:0 6px 18px rgba(0,0,0,0.6);}
  .heading{font-size:15px;font-weight:800;margin-bottom:8px;color:var(--text);display:flex;align-items:center;justify-content:space-between}
  .metric{display:flex;align-items:center;gap:12px}
  .value{font-size:26px;font-weight:800;color:var(--text)}
  .feature-value{font-size:18px;font-weight:700;color:var(--text)}
  .gear{cursor:pointer;padding:6px;border-radius:8px;background:rgba(255,255,255,0.02);color:var(--muted)}
  .badge{display:inline-block;padding:6px 10px;border-radius:999px;background:rgba(255,255,255,0.02);font-weight:700;color:var(--muted)}
  canvas{border-radius:8px;display:block}
  .wfTopBar{display:flex;gap:12px;align-items:center;margin-bottom:8px}
  .wfBlue{background:#2b7bff;padding:8px 12px;border-radius:8px;color:white;font-weight:800}
  .wfGreen{background:#16a34a;padding:8px 12px;border-radius:8px;color:white;font-weight:700}
  .footer{grid-column:1/-1;display:flex;justify-content:space-between;align-items:center;margin-top:10px}
  input[type="range"]{width:140px}
  @media (max-width:980px){.wrap{grid-template-columns:1fr;padding:12px}.grid{grid-template-columns:1fr}}
</style>
</head>
<body>
  <div class="wrap">
    <!-- Left column -->
    <div class="left">
      <div class="hero">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div>
            <h1>CARCAT 5G - Wave</h1>
            <div class="muted">Car Battery Monitor — BLE telemetry & config</div>
          </div>
          <div style="text-align:right">
            <div class="muted">Connected to</div>
            <div id="deviceName" class="badge">Not connected</div>
          </div>
        </div>

        <div style="margin-top:12px;display:flex;gap:8px">
          <button id="connectButton" class="btn">Connect</button>
          <button id="disconnectButton" class="ghost" disabled>Disconnect</button>
        </div>

        <div style="margin-top:12px;display:flex;gap:8px">
          <button id="sendLiveBtn" class="ghost" disabled>SEND LIVE</button>
          <button id="sendInitBtn" class="ghost" disabled>SEND INIT</button>
          <button id="startAutoBtn" class="ghost" disabled>Start Auto</button>
          <button id="stopAutoBtn" class="ghost" disabled>Stop Auto</button>
        </div>

        <div style="margin-top:12px" class="muted">Raw receive (Docklight hex)</div>
        <div id="recvRaw" class="raw"></div>

        <div style="margin-top:8px;display:flex;gap:8px">
          <button id="clearRaw" class="ghost">Clear</button>
          <button id="forceParse" class="ghost">Force LIVE Parse</button>
        </div>
      </div>

      <div class="tile" style="margin-top:8px">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div>
            <div style="font-weight:800">Quick</div>
            <div class="muted">Console TX/RX logs are in browser console</div>
          </div>
          <div><button id="openSetup" class="ghost">Setup</button></div>
        </div>
      </div>
    </div>

    <!-- Right column -->
    <div>
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px">
        <div style="font-size:18px;font-weight:800">Dashboard</div>
        <div class="muted">Auto: <span id="autoStatus">Idle</span></div>
      </div>

      <div class="grid">
        <div class="tile" id="card_voltage" style="border-left:6px solid #2dd4bf">
          <div class="heading"><div>Car Battery Voltage</div><div class="muted">LIVE</div></div>
          <div class="metric">
            <div class="value" id="card_battery">-- V</div>
            <div class="muted">instant</div>
          </div>
          <div class="muted" id="card_battery_sub">From LIVE</div>
        </div>

        <div class="tile" id="card_current" style="border-left:6px solid #ffd166">
          <div class="heading"><div>Device Current</div><div class="muted">LIVE</div></div>
          <div class="metric"><div class="value" id="card_current_val">-- mA</div></div>
          <div class="muted">Bytes 12-13</div>
        </div>

        <div class="tile" id="card_temp" style="border-left:6px solid #f59e0b">
          <div class="heading"><div>Internal Temperature</div></div>
          <div class="feature-value" id="card_temp_value">-- °C</div>
          <div class="muted">From LIVE</div>
        </div>

        <div class="tile" id="card_minfreq" style="border-left:6px solid #10b981">
          <div class="heading"><div>Min Frequency (current)</div></div>
          <div class="feature-value" id="card_minfreq_val">-- kHz</div>
          <div class="muted">From LIVE</div>
        </div>

        <div class="tile" id="card_maxfreq" style="border-left:6px solid #fb923c">
          <div class="heading"><div>Max Frequency (current)</div></div>
          <div class="feature-value" id="card_maxfreq_val">-- kHz</div>
          <div class="muted">From LIVE</div>
        </div>

        <div class="tile" id="card_wave" style="border-left:6px solid #7c3aed">
          <div class="heading"><div>Wave velocity</div></div>
          <div class="feature-value" id="card_waveval">-- ppm</div>
          <div class="muted">Controls waterfall sweep speed</div>
        </div>

        <!-- Waterfall tile (grid-column full width) -->
        <div class="tile" id="card_waterfall" style="grid-column:1/-1;border-left:6px solid #0ea5e9">
          <div class="heading"><div>Visualization (Waterfall)</div><div class="muted">Radio-style waterfall</div></div>
          <div class="wfTopBar">
            <div class="wfBlue" id="wfCurrentFreq">-- kHz</div>
            <div class="wfGreen" id="wfStep">Step: --/--</div>
            <div class="muted" id="wfRange">Range: -- kHz</div>
            <div style="margin-left:12px" class="muted">Bins</div>
            <input id="wfBinsSlider" type="range" min="10" max="100" value="100">
            <div class="badge" id="wfBinsLabel">100</div>
          </div>
          <canvas id="waterfallCanvas" style="width:100%;height:240px;background:#041028;border-radius:8px;display:block"></canvas>
          <div style="margin-top:8px" class="muted">Time → upward • Intensity: blue (weak) → red (strong)</div>
        </div>

        <!-- Feature cards (unchanged layout) -->
        <div class="tile" id="feat_beep_card" style="border-left:6px solid #ff6fa6">
          <div style="display:flex;justify-content:space-between;align-items:center">
            <div><div style="font-weight:800">Audible beep</div><div class="muted">Duration (after every)</div></div>
            <div style="text-align:right"><div id="beep_enabled_card" class="muted">Disabled</div><div class="gear" data-feature="beep">⚙</div></div>
          </div>
          <div style="margin-top:8px;display:flex;gap:12px;align-items:center">
            <div><div class="muted">Set</div><div class="feature-value" id="beep_set">-- s</div></div>
            <div><div class="muted">Default</div><div class="muted" id="beep_default_card">-- s</div></div>
            <div><div class="muted">Min/Max</div><div class="muted" id="beep_minmax">-- / -- s</div></div>
          </div>
        </div>

        <div class="tile" id="feat_standby_card" style="border-left:6px solid #06b6d4">
          <div style="display:flex;justify-content:space-between;align-items:center">
            <div><div style="font-weight:800">Standby mode</div><div class="muted">Charging voltage threshold</div></div>
            <div style="text-align:right"><div id="standby_enabled_card" class="muted">Disabled</div><div class="gear" data-feature="standby">⚙</div></div>
          </div>
          <div style="margin-top:8px;display:flex;gap:12px;align-items:center">
            <div><div class="muted">Set</div><div class="feature-value" id="standby_set">-- V</div></div>
            <div><div class="muted">Default</div><div class="muted" id="standby_default_card">-- V</div></div>
            <div><div class="muted">Min/Max</div><div class="muted" id="standby_minmax">-- / -- V</div></div>
          </div>
        </div>

        <div class="tile" id="feat_shutdown_card" style="border-left:6px solid #c084fc">
          <div style="display:flex;justify-content:space-between;align-items:center">
            <div><div style="font-weight:800">Shutdown mode</div><div class="muted">Cut-off voltage</div></div>
            <div style="text-align:right"><div id="shutdown_enabled_card" class="muted">Disabled</div><div class="gear" data-feature="shutdown">⚙</div></div>
          </div>
          <div style="margin-top:8px;display:flex;gap:12px;align-items:center">
            <div><div class="muted">Set</div><div class="feature-value" id="shutdown_set">-- V</div></div>
            <div><div class="muted">Default</div><div class="muted" id="shutdown_default_card">-- V</div></div>
            <div><div class="muted">Min/Max</div><div class="muted" id="shutdown_minmax">-- / -- V</div></div>
          </div>
        </div>

        <div class="tile" id="feat_hiss_card" style="border-left:6px solid #34d399">
          <div style="display:flex;justify-content:space-between;align-items:center">
            <div><div style="font-weight:800">Audible Hiss band</div><div class="muted">Play frequency</div></div>
            <div style="text-align:right"><div id="hiss_enabled_card" class="muted">Disabled</div><div class="gear" data-feature="hiss">⚙</div></div>
          </div>
          <div style="margin-top:8px;display:flex;gap:12px;align-items:center">
            <div><div class="muted">Set</div><div class="feature-value" id="hiss_set">-- %</div></div>
            <div><div class="muted">Default</div><div class="muted" id="hiss_default_card">-- %</div></div>
            <div><div class="muted">Min/Max</div><div class="muted" id="hiss_minmax">-- / -- %</div></div>
          </div>
        </div>

      </div>

      <div class="footer">
        <div style="display:flex;gap:12px;align-items:center">
          <div id="statusDot" style="width:12px;height:12px;border-radius:50%;background:#ff6b6b"></div>
          <div class="muted" id="bleText">Disconnected</div>
        </div>
        <div><button id="copyParsed" class="ghost">Copy LIVE</button> <button id="copyInit" class="ghost">Copy INIT</button></div>
      </div>

    </div>
  </div>

  <!-- Modal (unchanged minimal) -->
  <div id="modalBackdrop" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,.55);align-items:center;justify-content:center;z-index:2000">
    <div style="width:420px;background:#f6fbff;padding:16px;border-radius:10px;color:#0b1220">
      <div style="text-align:right"><span id="modalClose" style="cursor:pointer">✕</span></div>
      <h3 id="modalTitle">Feature</h3>
      <div style="display:flex;justify-content:center;align-items:center;gap:12px;margin:10px 0">
        <div class="muted">Disabled</div>
        <div id="modalToggle" style="width:54px;height:30px;background:#ddd;border-radius:18px;position:relative;cursor:pointer"><div class="knob" style="width:24px;height:24px;border-radius:50%;background:#fff;position:absolute;left:3px;top:3px;transition:left .12s"></div></div>
        <div class="muted">Enabled</div>
      </div>
      <div style="text-align:center">
        <div id="sliderLabel" class="muted">Duration</div>
        <input id="modalSlider" type="range" min="0" max="100" step="1" style="width:100%;margin-top:12px"/>
        <div id="modalSliderValue" style="font-weight:800;margin-top:10px">0</div>
      </div>
      <div style="display:flex;justify-content:space-between;margin-top:14px">
        <button id="modalReset" class="ghost">Reset</button>
        <div><button id="modalSave" class="btn">Save</button></div>
      </div>
    </div>
  </div>

<script>
/* === Full app: BLE + parsing + modal + save ACK + waterfall (updated) === */

/* UUIDs & frames */
const serviceUuid = "0000fff0-0000-1000-8000-00805f9b34fb";
const notifyCharUuid = "0000fff1-0000-1000-8000-00805f9b34fb";
const writeCharUuid = "0000fff2-0000-1000-8000-00805f9b34fb";

const LIVE_CMD_HEX = "FD FC FB FA 04 00 4C 49 56 45 04 03 02 01";
const INIT_CMD_HEX = "FD FC FB FA 04 00 49 4E 49 54 04 03 02 01";

/* CMD bytes */
const CMD_BYTES = {
  beep: [0x42,0x45,0x45,0x50],     // "BEEP"
  standby: [0x53,0x54,0x41,0x4E],  // "STAN"
  shutdown: [0x53,0x48,0x55,0x54], // "SHUT"
  hiss: [0x48,0x49,0x53,0x53]      // "HISS"
};

/* DOM refs */
const connectButton = document.getElementById("connectButton");
const disconnectButton = document.getElementById("disconnectButton");
const sendLiveBtn = document.getElementById("sendLiveBtn");
const sendInitBtn = document.getElementById("sendInitBtn");
const startAutoBtn = document.getElementById("startAutoBtn");
const stopAutoBtn = document.getElementById("stopAutoBtn");
const recvRaw = document.getElementById("recvRaw");
const clearRaw = document.getElementById("clearRaw");
const forceParse = document.getElementById("forceParse");
const deviceName = document.getElementById("deviceName");
const bleText = document.getElementById("bleText");
const statusDot = document.getElementById("statusDot");
const autoStatus = document.getElementById("autoStatus");

/* LIVE card elements */
const card_battery = document.getElementById("card_battery");
const card_current_val = document.getElementById("card_current_val");
const card_temp_value = document.getElementById("card_temp_value");
const card_minfreq_val = document.getElementById("card_minfreq_val");
const card_maxfreq_val = document.getElementById("card_maxfreq_val");
const card_waveval = document.getElementById("card_waveval");

/* INIT feature elements */
const beep_enabled_card = document.getElementById("beep_enabled_card");
const beep_set = document.getElementById("beep_set");
const beep_default_card = document.getElementById("beep_default_card");
const beep_minmax = document.getElementById("beep_minmax");

const standby_enabled_card = document.getElementById("standby_enabled_card");
const standby_set = document.getElementById("standby_set");
const standby_default_card = document.getElementById("standby_default_card");
const standby_minmax = document.getElementById("standby_minmax");

const shutdown_enabled_card = document.getElementById("shutdown_enabled_card");
const shutdown_set = document.getElementById("shutdown_set");
const shutdown_default_card = document.getElementById("shutdown_default_card");
const shutdown_minmax = document.getElementById("shutdown_minmax");

const hiss_enabled_card = document.getElementById("hiss_enabled_card");
const hiss_set = document.getElementById("hiss_set");
const hiss_default_card = document.getElementById("hiss_default_card");
const hiss_minmax = document.getElementById("hiss_minmax");

/* modal refs */
const modalBackdrop = document.getElementById('modalBackdrop');
const modalToggle = document.getElementById('modalToggle');
const modalSlider = document.getElementById('modalSlider');
const modalSliderValue = document.getElementById('modalSliderValue');
const modalReset = document.getElementById('modalReset');
const modalSave = document.getElementById('modalSave');
const modalClose = document.getElementById('modalClose');
const modalTitle = document.getElementById('modalTitle');

/* waterfall UI refs */
const wfCurrentFreq = document.getElementById('wfCurrentFreq');
const wfStepEl = document.getElementById('wfStep');
const wfRangeEl = document.getElementById('wfRange');
const wfCanvas = document.getElementById('waterfallCanvas');
const wfBinsSlider = document.getElementById('wfBinsSlider');
const wfBinsLabel = document.getElementById('wfBinsLabel');

/* state */
let device, server, notifyChar, writeChar;
let lastPacket = null;
let currentInitData = null;
let autoIntervalId = null;
let writeInProgress = false;
let editingFeature = null;
let pendingSave = null;
let awaitingInitPromise = null;

/* helper utils */
function hexToBytes(hexStr){
  const cleaned = hexStr.replace(/0x/g,"").replace(/[^A-Fa-f0-9]/g,"");
  const out = new Uint8Array(cleaned.length/2);
  for(let i=0;i<cleaned.length;i+=2) out[i/2] = parseInt(cleaned.substr(i,2),16);
  return out;
}
function bytesToHexUpper(bytes){
  return Array.from(bytes).map(b=>b.toString(16).padStart(2,'0').toUpperCase()).join(' ');
}
function appendRaw(bytes, label=''){
  const t = new Date().toLocaleTimeString();
  lastPacket = bytes;
  const tag = label ? ` [${label}]` : '';
  recvRaw.innerHTML += `[${t}]${tag} ${bytesToHexUpper(bytes)}<br>`;
  recvRaw.scrollTop = recvRaw.scrollHeight;
  console.log(`RX${tag}: ${bytesToHexUpper(bytes)}`);
}
function readU8(buf, idx){ return (idx < buf.length) ? buf[idx] : null; }
function readU16le(buf, lo, hi){ const l=readU8(buf,lo), h=readU8(buf,hi); if(l===null||h===null) return null; return (h<<8) | l; }
function isTagAt(buf, offset, tagStr){ if(!buf || buf.length < offset + tagStr.length) return false; for(let i=0;i<tagStr.length;i++) if(buf[offset+i] !== tagStr.charCodeAt(i)) return false; return true; }

/* === LIVE/INIT parsers & UI updates (unchanged logic from previous) === */
function parseLivePacket(bytes){
  const buf = Uint8Array.from(bytes);
  if(buf.length < 28) return { error:"LIVE too short" };
  return {
    battery_mV: readU16le(buf,10,11),
    current_mA: (() => { const raw = readU16le(buf,12,13); return (raw != null) ? (raw/1000) : null; })(),
    temp_raw: readU16le(buf,14,15),
    min_Hz: readU16le(buf,16,17),
    max_Hz: readU16le(buf,18,19),
    waveVal: readU16le(buf,20,21),
    pattern: readU8(buf,22),
    days: readU16le(buf,23,24),
    hh: readU8(buf,25), mm: readU8(buf,26), ss: readU8(buf,27),
    rawHex: bytesToHexUpper(buf)
  };
}
function showLive(obj){
  if(!obj || obj.error) return;
  card_battery.textContent = (obj.battery_mV != null) ? (obj.battery_mV/1000).toFixed(3) + " V" : "-- V";
  card_current_val.textContent = (obj.current_mA != null) ? obj.current_mA.toFixed(3) + " mA" : "-- mA";
  card_temp_value.textContent = (obj.temp_raw != null) ? (obj.temp_raw/100).toFixed(2) + " °C" : "-- °C";
  card_minfreq_val.textContent = (obj.min_Hz != null) ? (obj.min_Hz/1000).toFixed(3) + " kHz" : "-- kHz";
  card_maxfreq_val.textContent = (obj.max_Hz != null) ? (obj.max_Hz/1000).toFixed(3) + " kHz" : "-- kHz";
  card_waveval.textContent = (obj.waveVal != null) ? obj.waveVal.toString() + " ppm" : "-- ppm";

  // update waterfall: this will start the waterfall on first valid LIVE
  const min_khz = (obj.min_Hz != null) ? (obj.min_Hz/1000.0) : 20.0;
  const max_khz = (obj.max_Hz != null) ? (obj.max_Hz/1000.0) : 60.0;
  const ppm = (obj.waveVal != null && obj.waveVal > 0) ? obj.waveVal : 1;
  if(window.WaterfallChart && typeof window.WaterfallChart.updateFromLive === 'function') {
    window.WaterfallChart.updateFromLive(min_khz, max_khz, ppm);
  }
}

function parseInitPacket(bytes){
  const buf = Uint8Array.from(bytes);
  if(buf.length < 51) return { error:"INIT too short" };

  const beep_en = readU8(buf,11);
  const beep_en_default = readU8(buf,12);
  const beep_val = readU16le(buf,13,14);
  const beep_min = readU16le(buf,15,16);
  const beep_max = readU16le(buf,17,18);
  const beep_def = readU16le(buf,19,20);

  const standby_en = readU8(buf,21);
  const standby_en_default = readU8(buf,22);
  const standby_val = readU16le(buf,23,24);
  const standby_minv = readU16le(buf,25,26);
  const standby_maxv = readU16le(buf,27,28);
  const standby_defv = readU16le(buf,29,30);

  const shutdown_en = readU8(buf,31);
  const shutdown_en_default = readU8(buf,32);
  const shutdown_val = readU16le(buf,33,34);
  const shutdown_minv = readU16le(buf,35,36);
  const shutdown_maxv = readU16le(buf,37,38);
  const shutdown_defv = readU16le(buf,39,40);

  const hiss_en = readU8(buf,41);
  const hiss_en_default = readU8(buf,42);
  const hiss_val = readU16le(buf,43,44);
  const hiss_minv = readU16le(buf,45,46);
  const hiss_maxv = readU16le(buf,47,48);
  const hiss_defv = readU16le(buf,49,50);

  return {
    beep:{enabled:beep_en===1,en_default:beep_en_default===1,value:beep_val,min:beep_min,max:beep_max,def:beep_def},
    standby:{enabled:standby_en===1,en_default:standby_en_default===1,value_mV:standby_val,min_mV:standby_minv,max_mV:standby_maxv,def_mV:standby_defv},
    shutdown:{enabled:shutdown_en===1,en_default:shutdown_en_default===1,value_mV:shutdown_val,min_mV:shutdown_minv,max_mV:shutdown_maxv,def_mV:shutdown_defv},
    hiss:{enabled:hiss_en===1,en_default:hiss_en_default===1,value_pct:hiss_val,min_pct:hiss_minv,max_pct:hiss_maxv,def_pct:hiss_defv},
    rawHex: bytesToHexUpper(buf), _rawBuf: buf
  };
}
function showInit(obj){
  if(!obj || obj.error){ currentInitData = null; return; }
  currentInitData = obj;

  beep_enabled_card.textContent = obj.beep.enabled ? "Enabled" : "Disabled";
  beep_set.textContent = (obj.beep.value!=null) ? `${obj.beep.value} s` : "-- s";
  beep_default_card.textContent = (obj.beep.def!=null) ? `${obj.beep.def} s` : "-- s";
  beep_minmax.textContent = `${obj.beep.min ?? "--"} / ${obj.beep.max ?? "--"} s`;

  standby_enabled_card.textContent = obj.standby.enabled ? "Enabled" : "Disabled";
  standby_set.textContent = (obj.standby.value_mV!=null) ? `${(obj.standby.value_mV/1000).toFixed(3)} V` : "-- V";
  standby_default_card.textContent = (obj.standby.def_mV!=null) ? `${(obj.standby.def_mV/1000).toFixed(3)} V` : "-- V";
  standby_minmax.textContent = `${(obj.standby.min_mV!=null ? (obj.standby.min_mV/1000).toFixed(3):"--")} / ${(obj.standby.max_mV!=null ? (obj.standby.max_mV/1000).toFixed(3):"--")} V`;

  shutdown_enabled_card.textContent = obj.shutdown.enabled ? "Enabled" : "Disabled";
  shutdown_set.textContent = (obj.shutdown.value_mV!=null) ? `${(obj.shutdown.value_mV/1000).toFixed(3)} V` : "-- V";
  shutdown_default_card.textContent = (obj.shutdown.def_mV!=null) ? `${(obj.shutdown.def_mV/1000).toFixed(3)} V` : "-- V";
  shutdown_minmax.textContent = `${(obj.shutdown.min_mV!=null ? (obj.shutdown.min_mV/1000).toFixed(3):"--")} / ${(obj.shutdown.max_mV!=null ? (obj.shutdown.max_mV/1000).toFixed(3):"--")} V`;

  hiss_enabled_card.textContent = obj.hiss.enabled ? "Enabled" : "Disabled";
  hiss_set.textContent = (obj.hiss.value_pct!=null) ? `${obj.hiss.value_pct} %` : "-- %";
  hiss_default_card.textContent = (obj.hiss.def_pct!=null) ? `${obj.hiss.def_pct} %` : "-- %";
  hiss_minmax.textContent = `${obj.hiss.min_pct ?? "--"} / ${obj.hiss.max_pct ?? "--"} %`;

  console.log("INIT parsed & UI updated");
}

/* write helper */
async function writeFrame(bytes, label){
  if(!writeChar) throw new Error("Not connected");
  console.log("TX " + label + ": " + bytesToHexUpper(bytes));
  try { writeInProgress = true; await writeChar.writeValue(bytes); }
  catch(e){ console.error("Write error:", e); throw e; }
  finally{ writeInProgress = false; }
}
async function sendLiveCmd(){ if(writeInProgress) return console.warn("Write in progress"); const d = hexToBytes(LIVE_CMD_HEX); await writeFrame(d, "LIVE"); }
async function sendInitCmd(){ if(writeInProgress) return console.warn("Write in progress"); const d = hexToBytes(INIT_CMD_HEX); await writeFrame(d, "INIT"); }

/* Connect / disconnect */
async function connect() {
  console.log("Connect button clicked");
  if (!navigator.bluetooth) {
    alert("Web Bluetooth is not available in this browser. Use Chrome/Chromium.");
    return;
  }
  try {
    device = await navigator.bluetooth.requestDevice({ filters: [{ namePrefix: "CARCAT" }, { name: "CARCAT_5G" }], optionalServices: [serviceUuid] });
    if (!device) return;
    device.addEventListener("gattserverdisconnected", onDeviceDisconnected);
    server = await device.gatt.connect();
    const svc = await server.getPrimaryService(serviceUuid);
    notifyChar = await svc.getCharacteristic(notifyCharUuid);
    writeChar = await svc.getCharacteristic(writeCharUuid);
    await notifyChar.startNotifications();
    notifyChar.addEventListener("characteristicvaluechanged", onNotify);

    deviceName.textContent = device.name || device.id;
    bleText.textContent = "Connected";
    statusDot.style.background = "#10b981";

    connectButton.disabled = true;
    disconnectButton.disabled = false;
    sendLiveBtn.disabled = false;
    sendInitBtn.disabled = false;
    startAutoBtn.disabled = false;
    stopAutoBtn.disabled = true;
  } catch (err) {
    console.error("Connect failed:", err);
    deviceName.textContent = "Not connected";
    bleText.textContent = "Disconnected";
    statusDot.style.background = "#ff6b6b";
    connectButton.disabled = false;
  }
}
function onDeviceDisconnected() {
  console.log("Device disconnected");
  deviceName.textContent = "Not connected";
  bleText.textContent = "Disconnected";
  statusDot.style.background = "#ff6b6b";
  connectButton.disabled = false;
  disconnectButton.disabled = true;
  sendLiveBtn.disabled = true;
  sendInitBtn.disabled = true;
  startAutoBtn.disabled = true;
  stopAutoBtn.disabled = true;
}
async function disconnect() { try{ if(device && device.gatt.connected) device.gatt.disconnect(); }catch(e){console.warn(e);} onDeviceDisconnected(); }

/* Handle notifications */
function onNotify(ev){
  const arr = new Uint8Array(ev.target.value.buffer);

  if (isTagAt(arr, 6, "LIVE") && arr.length >= 28) {
    appendRaw(arr, 'LIVE');
    const liveParsed = parseLivePacket(arr);
    if (!liveParsed.error) showLive(liveParsed);
    return;
  }

  if (isTagAt(arr, 6, "INIT") && arr.length >= 51) {
    appendRaw(arr, 'INIT');
    const initParsed = parseInitPacket(arr);
    if (!initParsed.error) {
      showInit(initParsed);

      if (awaitingInitPromise && typeof awaitingInitPromise._resolve === 'function') {
        awaitingInitPromise._resolve(initParsed);
        awaitingInitPromise = null;
      }

      // check pending save ack (byte index 10 == 1)
      try {
        const buf = initParsed._rawBuf;
        if (pendingSave && buf && buf.length > 10 && buf[10] === 1) {
          console.log("ACK INIT received (byte10==1) for pending save");
          pendingSave.resolve({ feature: pendingSave.feature, value: pendingSave.value, buf });
          pendingSave = null;
        }
      } catch (e) { console.warn("ack check error", e); }
    }
    return;
  }

  appendRaw(arr, '');
}

/* Auto LIVE */
function startAutoLive(){
  if(autoIntervalId) return;
  if(!writeChar){ alert("Not connected"); return; }
  autoStatus.textContent = "Auto ON";
  startAutoBtn.disabled = true;
  stopAutoBtn.disabled = false;
  autoIntervalId = setInterval(()=>{ if(!writeInProgress) sendLiveCmd(); },500);
}
function stopAutoLive(){
  if(autoIntervalId) clearInterval(autoIntervalId);
  autoIntervalId = null;
  autoStatus.textContent = "Idle";
  startAutoBtn.disabled = false;
  stopAutoBtn.disabled = true;
}

/* Wait utilities */
function waitForNextInit(timeoutMs = 3000) {
  if (awaitingInitPromise) return awaitingInitPromise;
  let timer;
  awaitingInitPromise = new Promise((resolve, reject) => {
    timer = setTimeout(() => { awaitingInitPromise = null; reject(new Error("INIT timeout")); }, timeoutMs);
    awaitingInitPromise._resolve = (initParsed) => { clearTimeout(timer); awaitingInitPromise = null; resolve(initParsed); };
  });
  return awaitingInitPromise;
}
function waitForInitAck(feature, value, timeoutMs = 5000){
  if(pendingSave) throw new Error("pendingSave already exists");
  return new Promise((resolve, reject) => {
    const timer = setTimeout(() => { if (pendingSave) pendingSave = null; reject(new Error("timeout")); }, timeoutMs);
    pendingSave = { feature, value,
      resolve: (info) => { clearTimeout(timer); pendingSave = null; resolve(info); },
      reject: (err) => { clearTimeout(timer); pendingSave = null; reject(err); }
    };
  });
}

/* build & send save frame */
async function performSaveWrite(featureKey, enabledNow, sliderRaw){
  if(!writeChar) throw new Error("Not connected");
  if(writeInProgress) throw new Error("Write in progress");
  const cmd = CMD_BYTES[featureKey];
  if(!cmd) throw new Error("Unknown feature cmd");

  const frame = new Uint8Array(4 + 2 + 4 + 1 + 2 + 4);
  let p = 0;
  frame[p++] = 0xFD; frame[p++] = 0xFC; frame[p++] = 0xFB; frame[p++] = 0xFA;
  frame[p++] = 0x07; frame[p++] = 0x00;
  frame[p++] = cmd[0]; frame[p++] = cmd[1]; frame[p++] = cmd[2]; frame[p++] = cmd[3];
  frame[p++] = enabledNow & 0xFF;
  frame[p++] = sliderRaw & 0xFF;
  frame[p++] = (sliderRaw >> 8) & 0xFF;
  frame[p++] = 0x04; frame[p++] = 0x03; frame[p++] = 0x02; frame[p++] = 0x01;

  console.log(`TX SAVE [${featureKey}] (EN=${enabledNow}) : ${bytesToHexUpper(frame)}`);
  await writeFrame(frame, `SAVE-${featureKey}`);

  return waitForInitAck(featureKey, sliderRaw, 5000);
}

/* modal logic (unchanged) */
function updateModalSliderValueDisplaySeconds(){ modalSliderValue.textContent = modalSlider.value + " s"; }
function updateModalSliderValueDisplayVolts(){ modalSliderValue.textContent = (modalSlider.value/1000).toFixed(3) + " V"; }
function updateModalSliderValueDisplayPercent(){ modalSliderValue.textContent = modalSlider.value + " %"; }

function openFeatureModal(featureKey){
  if(!currentInitData) return alert("No INIT data available yet. Send INIT to populate.");
  const data = currentInitData[featureKey];
  if(!data) return alert("Feature data missing");
  editingFeature = featureKey;
  modalTitle.textContent = ({beep:"Audible beep", standby:"Standby mode", shutdown:"Shutdown mode", hiss:"Audible Hiss band"})[featureKey] || "Edit Feature";
  if(data.enabled) modalToggle.classList.add('on'); else modalToggle.classList.remove('on');

  if(featureKey === 'beep'){
    modalSlider.min = data.min ?? 0; modalSlider.max = data.max ?? Math.max((data.min||0)+1, data.value||0);
    modalSlider.step = 1; modalSlider.value = data.value ?? data.def ?? modalSlider.min;
    sliderLabel.textContent = "Duration - (after every)";
    updateModalSliderValueDisplaySeconds();
  } else if(featureKey === 'standby' || featureKey === 'shutdown'){
    const rawMin = data.min_mV ?? 0; const rawMax = data.max_mV ?? Math.max(rawMin+1, data.value_mV||0);
    modalSlider.min = rawMin; modalSlider.max = rawMax; modalSlider.step = 1;
    modalSlider.value = data.value_mV ?? data.def_mV ?? modalSlider.min;
    sliderLabel.textContent = featureKey === 'standby' ? "Charging voltage threshold" : "Cut-off voltage";
    updateModalSliderValueDisplayVolts();
  } else if(featureKey === 'hiss'){
    modalSlider.min = data.min_pct ?? 0; modalSlider.max = data.max_pct ?? Math.max((data.min_pct||0)+1, data.value_pct||0);
    modalSlider.step = 1; modalSlider.value = data.value_pct ?? data.def_pct ?? modalSlider.min;
    sliderLabel.textContent = "Play frequency (band %)";
    updateModalSliderValueDisplayPercent();
  }
  modalBackdrop.style.display = 'flex';
}
modalToggle.addEventListener('click', ()=> {
  modalToggle.classList.toggle('on');
  const knob = modalToggle.querySelector('.knob');
  if(!knob) return;
  if(modalToggle.classList.contains('on')) knob.style.left = '27px'; else knob.style.left = '3px';
});
modalSlider.addEventListener('input', ()=>{
  if(editingFeature === 'beep') updateModalSliderValueDisplaySeconds();
  else if(editingFeature === 'standby' || editingFeature === 'shutdown') updateModalSliderValueDisplayVolts();
  else if(editingFeature === 'hiss') updateModalSliderValueDisplayPercent();
});
modalReset.addEventListener('click', ()=>{
  if(!editingFeature || !currentInitData) return;
  const d = currentInitData[editingFeature];
  if(!d) return;
  if(d.en_default) modalToggle.classList.add('on'); else modalToggle.classList.remove('on');
  if(editingFeature === 'beep'){ modalSlider.value = (d.def!=null)?d.def:(d.value!=null?d.value:modalSlider.min); updateModalSliderValueDisplaySeconds(); }
  else if(editingFeature === 'standby' || editingFeature === 'shutdown'){ modalSlider.value = (d.def_mV!=null)?d.def_mV:(d.value_mV!=null?d.value_mV:modalSlider.min); updateModalSliderValueDisplayVolts(); }
  else if(editingFeature === 'hiss'){ modalSlider.value = (d.def_pct!=null)?d.def_pct:(d.value_pct!=null?d.value_pct:modalSlider.min); updateModalSliderValueDisplayPercent(); }
});
modalClose.addEventListener('click', ()=> modalBackdrop.style.display='none');
modalBackdrop.addEventListener('click', e => { if(e.target === modalBackdrop) modalBackdrop.style.display = 'none'; });

modalSave.addEventListener('click', async ()=>{
  if(!editingFeature || !currentInitData){ modalBackdrop.style.display='none'; return; }
  if(!writeChar) { alert("Not connected — can't send save command"); return; }
  if(writeInProgress) { alert("Write in progress — try again"); return; }

  const enabledNow = modalToggle.classList.contains('on') ? 1 : 0;
  const sliderRaw = parseInt(modalSlider.value,10);
  modalSave.disabled = true; const prevText = modalSave.textContent; modalSave.textContent = "Saving...";
  try{
    await performSaveWrite(editingFeature, enabledNow, sliderRaw);
    if(editingFeature === 'beep'){ currentInitData.beep.enabled = enabledNow===1; currentInitData.beep.value = sliderRaw; }
    else if(editingFeature === 'standby'){ currentInitData.standby.enabled = enabledNow===1; currentInitData.standby.value_mV = sliderRaw; }
    else if(editingFeature === 'shutdown'){ currentInitData.shutdown.enabled = enabledNow===1; currentInitData.shutdown.value_mV = sliderRaw; }
    else if(editingFeature === 'hiss'){ currentInitData.hiss.enabled = enabledNow===1; currentInitData.hiss.value_pct = sliderRaw; }
    showInit(currentInitData);
    modalBackdrop.style.display='none';
    alert("Save acknowledged (INIT byte10=1).");
  }catch(e){
    console.warn("Save ACK error:", e);
    alert("No response received (timeout). Save not acknowledged.");
  }finally{
    modalSave.disabled = false; modalSave.textContent = prevText; pendingSave = null;
  }
});

/* gear wiring */
document.querySelectorAll('.gear').forEach(g => {
  g.addEventListener('click', async () => {
    const feature = g.dataset.feature;
    if (currentInitData) { openFeatureModal(feature); return; }
    if (!writeChar) { alert("Not connected. Please connect before editing features."); return; }
    try {
      await sendInitCmd();
      const initParsed = await waitForNextInit(3000);
      openFeatureModal(feature);
    } catch (err) {
      console.warn("Failed to get INIT before opening modal:", err);
      alert("Could not get INIT from device. Try sending INIT manually and try again.");
    }
  });
});

/* UI wiring for other controls */
connectButton.addEventListener('click', connect);
disconnectButton.addEventListener('click', disconnect);
sendLiveBtn.addEventListener('click', sendLiveCmd);
sendInitBtn.addEventListener('click', sendInitCmd);
startAutoBtn.addEventListener('click', startAutoLive);
stopAutoBtn.addEventListener('click', stopAutoLive);
clearRaw.addEventListener('click', ()=> recvRaw.innerHTML = '');
forceParse.addEventListener('click', ()=>{
  if(!lastPacket) return alert("No packet available");
  if(!isTagAt(lastPacket, 6, "LIVE")) return alert("Latest packet does not have 'LIVE' at bytes 6..9 — parsing skipped.");
  if(lastPacket.length < 28) return alert("LIVE packet too short (need ≥28 bytes).");
  const parsed = parseLivePacket(lastPacket);
  if(parsed.error) alert(parsed.error); else showLive(parsed);
});
document.getElementById('copyParsed').addEventListener('click', async ()=>{
  const lines = [
    `Battery (V): ${card_battery.textContent}`,
    `Current (mA): ${card_current_val.textContent}`,
    `Temp (°C): ${card_temp_value.textContent}`,
    `Min(kHz): ${card_minfreq_val.textContent}`,
    `Max(kHz): ${card_maxfreq_val.textContent}`
  ].join("\n");
  await navigator.clipboard.writeText(lines); alert("LIVE parsed copied");
});
document.getElementById('copyInit').addEventListener('click', async ()=>{ if(!currentInitData) return alert("No INIT"); await navigator.clipboard.writeText(JSON.stringify(currentInitData,null,2)); alert("INIT copied"); });

/* ============================
   WaterfallChart v2 (improved)
   - starts only after updateFromLive called first time
   - scrolls upward (time flows up) by copying canvas content up
   - adjustable bins via slider (10..100)
   - gaussian peak + noise, HSL color ramp
   - robust handling of resizing and bins changes
   ============================ */
(function WaterfallModule(){
  const canvas = wfCanvas;
  const ctx = canvas.getContext('2d', { alpha: false });
  const dpr = window.devicePixelRatio || 1;

  let bins = parseInt(wfBinsSlider.value,10) || 100;
  let min_khz = 20.0, max_khz = 60.0, ppm = 10;
  const ROW_H = 1;               // row height in CSS pixels
  const SIGMA = 2.2;
  const NOISE_LEVEL = 18;
  const MIN_STEP_MS = 4;
  const MAX_STEP_MS = 2000;

  let widthCss = 800, heightCss = 240;
  let binWidth = 1;
  let binFreqsHz = new Float32Array(bins);
  let started = false;           // don't animate until first updateFromLive
  let stepMs = 150;
  let lastTime = performance.now();
  let acc = 0;
  let stepCounter = 0;

  function resizeCanvas(){
    const cssW = Math.floor(canvas.clientWidth) || 600;
    const cssH = Math.floor(canvas.clientHeight) || 240;
    widthCss = cssW; heightCss = cssH;
    canvas.width = cssW * dpr;
    canvas.height = cssH * dpr;
    ctx.setTransform(dpr,0,0,dpr,0,0);
    binWidth = widthCss / bins;
    // clear background
    ctx.fillStyle = "#031025";
    ctx.fillRect(0,0,widthCss,heightCss);
  }
  window.addEventListener('resize', ()=> {
    resizeCanvas();
    // redraw clean slate
  });
  resizeCanvas();

  function computeBinFreqs(){
    const minHz = min_khz * 1000.0;
    const maxHz = max_khz * 1000.0;
    binFreqsHz = new Float32Array(bins);
    for(let i=0;i<bins;i++){
      const t = i/(bins-1);
      binFreqsHz[i] = minHz + t*(maxHz - minHz);
    }
  }
  computeBinFreqs();

  function ppmToMs(ppmVal){
    const forward = bins - 1;
    const stepsPerCycle = 2 * forward;
    const periodSeconds = 60.0 / Math.max(1e-6, ppmVal);
    let ms = (periodSeconds / stepsPerCycle) * 1000.0;
    ms = Math.max(MIN_STEP_MS, Math.min(MAX_STEP_MS, Math.round(ms)));
    return ms;
  }

  function activeBinForStep(st){
    const forward = bins - 1;
    const steps = 2 * forward;
    const s = st % steps;
    if(s <= forward) return s;
    return steps - s;
  }

  function makeRow(activeBin){
    const row = new Uint8ClampedArray(bins);
    const denom = 2 * SIGMA * SIGMA;
    for(let b=0;b<bins;b++){
      const d = b - activeBin;
      const g = Math.exp(-(d*d)/denom);
      let val = Math.round(240 * g + (Math.random() * NOISE_LEVEL));
      if(val < 6) val = 0;
      row[b] = Math.min(255, val);
    }
    return row;
  }

  function colorForIntensity(t){
    // t in [0..1], map to a pleasing blue->cyan->green->yellow->red
    const hue = 220 - (220 * t); // 220 (blue) -> 0 (red approx)
    const sat = 95;
    const light = Math.round(18 + 30 * t);
    return `hsl(${Math.round(hue)}, ${sat}%, ${light}%)`;
  }

  // scroll up using drawImage (fast) and draw new row at bottom
  function pushRow(row){
    const w = widthCss, h = heightCss;
    // scroll up by ROW_H pixels
    // drawImage uses source and destination in CSS px because of transform set earlier
    ctx.drawImage(canvas, 0, ROW_H, w, h - ROW_H, 0, 0, w, h - ROW_H);
    // clear bottom line
    ctx.fillStyle = "#031025";
    ctx.fillRect(0, h - ROW_H, w, ROW_H);

    // draw row at bottom y = h-ROW_H
    const y = h - ROW_H;
    for(let b=0;b<bins;b++){
      const intensity = row[b];
      if(intensity <= 0) continue;
      const t = intensity / 255.0;
      ctx.fillStyle = colorForIntensity(t);
      const x = Math.floor(b * binWidth);
      ctx.fillRect(x, y, Math.ceil(binWidth), ROW_H);
    }
  }

  function drawOverlay(activeBin){
    const freqHz = Math.round(binFreqsHz[activeBin] || 0);
    const freqk = (freqHz / 1000).toFixed(2);
    wfCurrentFreq.textContent = `${freqk} kHz`;
    wfStepEl.textContent = `Step: ${activeBin+1}/${bins}`;
    wfRangeEl.textContent = `Range: ${min_khz.toFixed(2)}–${max_khz.toFixed(2)} kHz`;
    wfBinsLabel.textContent = String(bins);
  }

  function loop(now){
    if(!started) { requestAnimationFrame(loop); return; }
    const dt = now - lastTime;
    lastTime = now;
    acc += dt;
    while(acc >= stepMs){
      const active = activeBinForStep(stepCounter);
      const row = makeRow(active);
      pushRow(row);
      drawOverlay(active);
      stepCounter = (stepCounter + 1) % (2*(bins - 1));
      acc -= stepMs;
    }
    requestAnimationFrame(loop);
  }

  // Public API
  function updateFromLive(minK, maxK, ppmVal){
    // update parameters and start waterfall (if not started)
    min_khz = minK || min_khz;
    max_khz = maxK || max_khz;
    ppm = (ppmVal && ppmVal > 0) ? ppmVal : ppm;
    computeBinFreqs();
    stepMs = ppmToMs(ppm);
    // ensure canvas resized to current bins mapping
    binWidth = widthCss / bins;
    if(!started){
      started = true;
      lastTime = performance.now();
      acc = 0;
      requestAnimationFrame(loop);
    }
  }

  function setBins(n){
    n = Math.max(10, Math.min(100, Math.round(n)));
    if(n === bins) return;
    // preserve some stepCounter fraction to avoid jump
    bins = n;
    computeBinFreqs();
    binWidth = widthCss / bins;
    // clear canvas so new resolution draws cleanly
    ctx.fillStyle = "#031025";
    ctx.fillRect(0,0,widthCss,heightCss);
    stepCounter = 0;
    acc = 0;
  }

  // expose
  window.WaterfallChart = {
    updateFromLive,
    setBins
  };

  // initialize and prepare loop (not started until updateFromLive called)
  resizeCanvas();
  lastTime = performance.now();
  requestAnimationFrame(loop);

  // wire bins slider
  wfBinsSlider.addEventListener('input', ()=> {
    const n = parseInt(wfBinsSlider.value,10);
    wfBinsLabel.textContent = String(n);
    try { window.WaterfallChart.setBins(n); }
    catch(e){ console.warn(e); }
  });

})();

/* initial checks */
if(!navigator.bluetooth){
  alert("Web Bluetooth not available in this browser.");
  connectButton.disabled = true;
  startAutoBtn.disabled = true;
  sendInitBtn.disabled = true;
  stopAutoBtn.disabled = true;
}

/* End of file */
</script>
</body>
</html>
