// --- Replace existing startAutoLive & stopAutoLive implementation with this ---

let autoRunning = false;   // flag to control loop
let autoLoopAbort = false; // allow immediate stop

// helper sleep
function sleep(ms){ return new Promise(res => setTimeout(res, ms)); }

// Compute delay between consecutive LIVE writes.
// Default if we don't have waveVal: 500ms. If you want it tied to ppm, adapt accordingly.
function computeAutoDelay(ppm) {
  // Keep a conservative default:
  if (!ppm || ppm <= 0) return 500;
  // A full min->max->min cycle contains 2*bins steps.
  // We previously used stepMs = (60s/ppm) / (2*bins) * 1000
  // For auto-send cadence we can just send once per step or once per sweep depending on device.
  // Use a safe per-step cadence: try (60s / ppm) / (2 * bins) if bins known from waterfall.
  try {
    const bins = window.SerpentineWaterfall ? (parseInt(document.getElementById('wfBinsSlider').value,10) || 46) : 46;
    const stepsPerCycle = 2 * Math.max(10, bins);
    const periodSec = 60.0 / ppm;
    const stepMs = Math.max(40, Math.round((periodSec / stepsPerCycle) * 1000)); // clamp min to 40ms
    return stepMs;
  } catch (e) {
    return 500;
  }
}

// Serial auto loop (one write at a time). Stops when autoRunning = false.
async function autoLoop() {
  console.log("Auto loop started");
  autoLoopAbort = false;
  while (autoRunning && !autoLoopAbort) {
    if (!writeChar) {
      console.warn("Auto loop: writeChar missing, stopping auto.");
      break;
    }
    // compute delay using the last known waveVal (read from UI or live parsed data)
    // If you maintain lastLive object, use it; otherwise fetch visible card_waveval text
    let ppm = null;
    try {
      const txt = document.getElementById('card_waveval').textContent || '';
      const match = txt.match(/(\d+(\.\d+)?)/);
      if (match) ppm = parseFloat(match[1]);
    } catch(e){ ppm = null; }

    const delayMs = computeAutoDelay(ppm);
    try {
      // Always call sendLiveCmd and await it so writes are serial
      await sendLiveCmd();
    } catch (err) {
      console.warn("Auto sendLiveCmd error", err);
      // If BLE write fails, break out to avoid tight infinite loop
      break;
    }

    // Wait the computed delay, but allow early stop
    const start = performance.now();
    while (autoRunning && !autoLoopAbort && (performance.now() - start) < delayMs) {
      // small sleep so we remain responsive to stop requests
      // using 50ms chunks prevents blocking the UI thread
      // but keeps the timing fairly accurate
      // adjust chunk size if you need more responsiveness
      // (smaller => more wakeups)
      // We avoid using a single await sleep(delayMs) so stop is responsive
      // to stopAutoLive() calls.
      // eslint-disable-next-line no-await-in-loop
      await sleep(50);
    }
  }
  console.log("Auto loop ended");
  autoRunning = false;
  // restore UI state
  startAutoBtn.disabled = false;
  stopAutoBtn.disabled = true;
  autoStatus.textContent = "Idle";
}

// start button handler
function startAutoLive() {
  if (autoRunning) return;
  if (!writeChar) { alert("Not connected"); return; }
  autoRunning = true;
  startAutoBtn.disabled = true;
  stopAutoBtn.disabled = false;
  autoStatus.textContent = "Auto ON";
  // start the serial loop (don't await it here)
  autoLoop().catch(e => { console.error("AutoLoop error", e); autoRunning = false; startAutoBtn.disabled=false; stopAutoBtn.disabled=true; autoStatus.textContent="Idle"; });
}

// stop button handler
function stopAutoLive() {
  if (!autoRunning) return;
  autoLoopAbort = true;    // signals loop to exit quickly
  autoRunning = false;
  // UI will be restored when loop ends, but restore immediately too:
  startAutoBtn.disabled = false;
  stopAutoBtn.disabled = true;
  autoStatus.textContent = "Stopping...";
  // small safety: clear abort after short delay
  setTimeout(()=> { autoLoopAbort = false; autoStatus.textContent = "Idle"; }, 300);
}
